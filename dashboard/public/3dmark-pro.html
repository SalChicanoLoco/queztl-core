<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ü¶Ö Queztl 3DMark Professional - WebGL Benchmark</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: #000;
            color: #fff;
            overflow: hidden;
        }

        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        #hud {
            position: fixed;
            top: 20px;
            left: 20px;
            font-family: 'Courier New', monospace;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.9);
            z-index: 1000;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid rgba(0, 255, 255, 0.5);
        }

        #fps-counter {
            color: #0f0;
            font-size: 32px;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .hud-metric {
            color: #0ff;
            font-size: 16px;
            margin: 5px 0;
        }

        .hud-label {
            color: #888;
            display: inline-block;
            width: 150px;
        }

        .hud-value {
            color: #fff;
            font-weight: bold;
        }

        #progress-bar {
            position: fixed;
            bottom: 50px;
            left: 50%;
            transform: translateX(-50%);
            width: 70%;
            height: 40px;
            background: rgba(0, 0, 0, 0.8);
            border: 3px solid #0ff;
            border-radius: 20px;
            overflow: hidden;
            z-index: 1000;
        }

        #progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #0f0, #0ff, #00f);
            width: 0%;
            transition: width 0.5s;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            font-weight: bold;
        }

        #test-label {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 48px;
            font-weight: bold;
            text-align: center;
            z-index: 999;
            text-shadow: 0 0 20px rgba(0, 255, 255, 0.8);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.5s;
        }

        #test-label.show {
            opacity: 1;
        }

        #start-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #0a0a0a, #1a1a2e, #0f0f23);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }

        #results-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #0a0a0a, #1a1a2e, #0f0f23);
            display: none;
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;
            z-index: 2000;
            overflow-y: auto;
            overflow-x: hidden;
            padding: 40px 40px 80px 40px;
        }

        h1 {
            font-size: 4em;
            background: linear-gradient(45deg, #00f260, #0575e6, #f0f);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 20px;
        }

        #start-button,
        #restart-button {
            padding: 20px 60px;
            font-size: 1.8em;
            background: linear-gradient(45deg, #00f260, #0575e6);
            border: none;
            border-radius: 50px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 0 30px rgba(5, 117, 230, 0.5);
            margin-top: 20px;
        }

        #start-button:hover,
        #restart-button:hover {
            transform: scale(1.1);
            box-shadow: 0 0 50px rgba(5, 117, 230, 0.8);
        }

        #api-input {
            padding: 15px 30px;
            font-size: 1.2em;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid #0575e6;
            border-radius: 10px;
            color: white;
            width: 500px;
            text-align: center;
            margin-bottom: 30px;
        }

        .grade-display {
            font-size: 5em;
            font-weight: bold;
            margin: 20px 0;
            text-shadow: 0 0 50px currentColor;
        }

        .results-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 25px;
            width: 100%;
            max-width: 1400px;
            margin: 40px 0;
        }

        .result-card {
            background: rgba(0, 0, 0, 0.6);
            border: 3px solid #0575e6;
            border-radius: 15px;
            padding: 25px;
            transition: all 0.3s;
        }

        .result-card:hover {
            border-color: #0ff;
            transform: translateY(-5px);
            box-shadow: 0 10px 40px rgba(0, 255, 255, 0.3);
        }

        .result-card h3 {
            color: #0ff;
            font-size: 1.8em;
            margin-bottom: 20px;
        }

        .result-metric {
            display: flex;
            justify-content: space-between;
            margin: 12px 0;
            font-size: 1.2em;
        }

        .loading {
            font-size: 1.5em;
            color: #0ff;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.3;
            }
        }

        .subtitle {
            font-size: 1.5em;
            color: #888;
            margin-bottom: 40px;
        }
    </style>
</head>

<body>
    <!-- Start Screen -->
    <div id="start-screen">
        <h1>ü¶Ö QUEZTL 3DMARK PROFESSIONAL</h1>
        <p class="subtitle">WebGL GPU Benchmark Suite</p>
        <input type="text" id="api-input" value="http://localhost:8000" placeholder="Queztl-Core API URL">
        <button id="start-button">‚ñ∂ START BENCHMARK</button>
        <p class="loading" id="loading" style="display:none; margin-top: 30px;">Initializing WebGL Engine...</p>
    </div>

    <!-- 3D Canvas Container -->
    <div id="canvas-container"></div>

    <!-- HUD -->
    <div id="hud" style="display:none;">
        <div id="fps-counter">FPS: 0</div>
        <div class="hud-metric">
            <span class="hud-label">Test:</span>
            <span class="hud-value" id="current-test">Initializing...</span>
        </div>
        <div class="hud-metric">
            <span class="hud-label">Objects:</span>
            <span class="hud-value" id="object-count">0</span>
        </div>
        <div class="hud-metric">
            <span class="hud-label">Triangles:</span>
            <span class="hud-value" id="triangle-count">0</span>
        </div>
        <div class="hud-metric">
            <span class="hud-label">Draw Calls:</span>
            <span class="hud-value" id="draw-calls">0</span>
        </div>
        <div class="hud-metric">
            <span class="hud-label">API Status:</span>
            <span class="hud-value" id="api-status">Ready</span>
        </div>
        <div class="hud-metric">
            <span class="hud-label">Score:</span>
            <span class="hud-value" id="current-score" style="color: #0f0;">0</span>
        </div>
    </div>

    <!-- Progress Bar -->
    <div id="progress-bar" style="display:none;">
        <div id="progress-fill">0%</div>
    </div>

    <!-- Test Label Overlay -->
    <div id="test-label"></div>

    <!-- Results Screen -->
    <div id="results-screen">
        <h1>üèÜ BENCHMARK COMPLETE</h1>
        <div class="grade-display" id="final-grade">A</div>
        <div class="results-grid" id="results-grid"></div>
        <button id="restart-button">üîÑ RUN AGAIN</button>
    </div>

    <!-- Three.js from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // Configuration
        let API_URL = 'http://localhost:8000';
        let scene, camera, renderer, composer;
        let objects = [];
        let lights = [];
        let isRunning = false;
        let currentTestIndex = 0;
        let frameCount = 0;
        let fps = 0;
        let lastTime = performance.now();
        let fpsHistory = [];
        let testResults = {};

        // Benchmark tests
        const tests = [
            {
                name: 'üåå Scene Complexity',
                duration: 6000,
                description: 'Complex 3D scene with multiple materials',
                setup: setupSceneComplexity,
                apiTest: null
            },
            {
                name: 'üí° Dynamic Lighting',
                duration: 6000,
                description: 'Real-time lighting with shadows',
                setup: setupDynamicLighting,
                apiTest: null
            },
            {
                name: 'üì¶ Geometry Processing',
                duration: 6000,
                description: 'High polygon count rendering',
                setup: setupGeometryTest,
                apiTest: 'geometry'
            },
            {
                name: 'üé® Material & Shaders',
                duration: 6000,
                description: 'Complex materials and shader effects',
                setup: setupMaterialTest,
                apiTest: null
            },
            {
                name: '‚ö° API Throughput',
                duration: 6000,
                description: 'Backend API stress test',
                setup: setupThroughputTest,
                apiTest: 'throughput'
            },
            {
                name: 'üåÄ Physics & Animation',
                duration: 6000,
                description: 'Dynamic object animation',
                setup: setupPhysicsTest,
                apiTest: null
            },
            {
                name: 'üóª TIN Terrain Model',
                duration: 6000,
                description: 'Triangulated Irregular Network terrain rendering',
                setup: setupTINTerrain,
                apiTest: null
            },
            {
                name: 'üì∏ Photogrammetry Mesh',
                duration: 6000,
                description: 'High-density point cloud to mesh conversion',
                setup: setupPhotogrammetry,
                apiTest: null
            },
            {
                name: 'ü§ñ AI Photogrammetry',
                duration: 6000,
                description: 'Synthetic 3D model generation',
                setup: setupAIPhotogrammetry,
                apiTest: null
            },
            {
                name: 'üó∫Ô∏è GIS Multi-Layer',
                duration: 6000,
                description: 'Multi-layer GIS visualization',
                setup: setupGISLayers,
                apiTest: null
            },
            {
                name: 'üíæ Memory Stress',
                duration: 6000,
                description: 'Large scene with memory management',
                setup: setupMemoryTest,
                apiTest: 'memory'
            }
        ];

        // Initialize Three.js
        function initThreeJS() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.002);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 30;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // Handle window resize
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        // Clear scene
        function clearScene() {
            while (scene.children.length > 0) {
                scene.remove(scene.children[0]);
            }
            objects = [];
            lights = [];
        }

        // Test Setups
        function setupSceneComplexity() {
            clearScene();

            // Ambient light
            const ambient = new THREE.AmbientLight(0x404040, 0.5);
            scene.add(ambient);

            // Point lights
            const colors = [0xff0000, 0x00ff00, 0x0000ff, 0xffff00, 0xff00ff, 0x00ffff];
            for (let i = 0; i < 6; i++) {
                const light = new THREE.PointLight(colors[i], 2, 50);
                light.position.set(
                    Math.cos(i * Math.PI / 3) * 20,
                    Math.sin(i * Math.PI / 3) * 20,
                    10
                );
                scene.add(light);
                lights.push(light);

                // Light sphere
                const sphere = new THREE.Mesh(
                    new THREE.SphereGeometry(0.5, 16, 16),
                    new THREE.MeshBasicMaterial({ color: colors[i] })
                );
                sphere.position.copy(light.position);
                scene.add(sphere);
                objects.push(sphere);
            }

            // Create grid of objects
            const geometries = [
                new THREE.BoxGeometry(1, 1, 1),
                new THREE.SphereGeometry(0.7, 32, 32),
                new THREE.ConeGeometry(0.7, 1.5, 32),
                new THREE.TorusGeometry(0.6, 0.2, 16, 100),
                new THREE.OctahedronGeometry(0.8, 0)
            ];

            for (let x = -15; x <= 15; x += 3) {
                for (let y = -10; y <= 10; y += 3) {
                    const geometry = geometries[Math.floor(Math.random() * geometries.length)];
                    const material = new THREE.MeshPhongMaterial({
                        color: Math.random() * 0xffffff,
                        shininess: 100,
                        specular: 0x555555
                    });
                    const mesh = new THREE.Mesh(geometry, material);
                    mesh.position.set(x, y, Math.random() * 20 - 10);
                    mesh.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
                    scene.add(mesh);
                    objects.push(mesh);
                }
            }

            updateMetrics();
        }

        function setupDynamicLighting() {
            clearScene();

            // Multiple colored lights
            const lightCount = 10;
            for (let i = 0; i < lightCount; i++) {
                const light = new THREE.PointLight(Math.random() * 0xffffff, 3, 40);
                light.position.set(
                    (Math.random() - 0.5) * 40,
                    (Math.random() - 0.5) * 40,
                    (Math.random() - 0.5) * 40
                );
                scene.add(light);
                lights.push(light);
            }

            // Central objects to reflect light
            const centerGeometry = new THREE.IcosahedronGeometry(5, 3);
            const centerMaterial = new THREE.MeshStandardMaterial({
                color: 0xffffff,
                metalness: 0.9,
                roughness: 0.1
            });
            const centerMesh = new THREE.Mesh(centerGeometry, centerMaterial);
            scene.add(centerMesh);
            objects.push(centerMesh);

            // Surrounding spheres
            for (let i = 0; i < 50; i++) {
                const geometry = new THREE.SphereGeometry(Math.random() * 2 + 0.5, 32, 32);
                const material = new THREE.MeshStandardMaterial({
                    color: Math.random() * 0xffffff,
                    metalness: Math.random(),
                    roughness: Math.random()
                });
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(
                    (Math.random() - 0.5) * 30,
                    (Math.random() - 0.5) * 30,
                    (Math.random() - 0.5) * 30
                );
                scene.add(mesh);
                objects.push(mesh);
            }

            updateMetrics();
        }

        function setupGeometryTest() {
            clearScene();

            const ambient = new THREE.AmbientLight(0x404040);
            scene.add(ambient);

            const directional = new THREE.DirectionalLight(0xffffff, 1);
            directional.position.set(5, 10, 5);
            scene.add(directional);

            // High poly objects
            const segments = 128;
            const geometries = [
                new THREE.SphereGeometry(3, segments, segments),
                new THREE.TorusKnotGeometry(2, 0.6, segments, 32),
                new THREE.IcosahedronGeometry(3, 5)
            ];

            for (let i = 0; i < 3; i++) {
                const material = new THREE.MeshPhongMaterial({
                    color: [0xff0000, 0x00ff00, 0x0000ff][i],
                    shininess: 100,
                    wireframe: false
                });
                const mesh = new THREE.Mesh(geometries[i], material);
                mesh.position.x = (i - 1) * 10;
                scene.add(mesh);
                objects.push(mesh);
            }

            updateMetrics();
        }

        function setupMaterialTest() {
            clearScene();

            const ambient = new THREE.AmbientLight(0x222222);
            scene.add(ambient);

            const light = new THREE.DirectionalLight(0xffffff, 1);
            light.position.set(10, 10, 10);
            scene.add(light);

            // Different material types
            const geometry = new THREE.TorusGeometry(2, 0.7, 32, 100);
            const materials = [
                new THREE.MeshBasicMaterial({ color: 0xff0000 }),
                new THREE.MeshLambertMaterial({ color: 0x00ff00 }),
                new THREE.MeshPhongMaterial({ color: 0x0000ff, shininess: 100 }),
                new THREE.MeshStandardMaterial({ color: 0xffff00, metalness: 0.8, roughness: 0.2 }),
                new THREE.MeshPhysicalMaterial({ color: 0xff00ff, metalness: 1, roughness: 0, clearcoat: 1 })
            ];

            for (let i = 0; i < materials.length; i++) {
                const mesh = new THREE.Mesh(geometry, materials[i]);
                mesh.position.x = (i - 2) * 6;
                scene.add(mesh);
                objects.push(mesh);
            }

            updateMetrics();
        }

        function setupThroughputTest() {
            clearScene();

            // Simple scene for API focus
            const ambient = new THREE.AmbientLight(0x404040);
            scene.add(ambient);

            const geometry = new THREE.BoxGeometry(2, 2, 2);
            const material = new THREE.MeshPhongMaterial({ color: 0x00ff00 });
            const cube = new THREE.Mesh(geometry, material);
            scene.add(cube);
            objects.push(cube);

            updateMetrics();
        }

        function setupPhysicsTest() {
            clearScene();

            const ambient = new THREE.AmbientLight(0x404040);
            scene.add(ambient);

            const light = new THREE.DirectionalLight(0xffffff, 1);
            light.position.set(5, 10, 5);
            scene.add(light);

            // Create bouncing spheres
            for (let i = 0; i < 100; i++) {
                const geometry = new THREE.SphereGeometry(Math.random() * 0.5 + 0.3, 16, 16);
                const material = new THREE.MeshPhongMaterial({
                    color: Math.random() * 0xffffff
                });
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(
                    (Math.random() - 0.5) * 30,
                    (Math.random() - 0.5) * 30,
                    (Math.random() - 0.5) * 30
                );
                mesh.userData.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.2,
                    (Math.random() - 0.5) * 0.2,
                    (Math.random() - 0.5) * 0.2
                );
                scene.add(mesh);
                objects.push(mesh);
            }

            updateMetrics();
        }

        function setupTINTerrain() {
            clearScene();

            // Lighting for terrain
            const ambient = new THREE.AmbientLight(0x404040);
            scene.add(ambient);

            const sun = new THREE.DirectionalLight(0xffffee, 1.5);
            sun.position.set(50, 100, 50);
            sun.castShadow = true;
            scene.add(sun);

            // Generate TIN terrain mesh
            const gridSize = 100; // 100x100 grid = 10,000 vertices
            const spacing = 1;
            const elevationScale = 15;

            // Create elevation data using Perlin-like noise
            const elevationData = [];
            for (let y = 0; y < gridSize; y++) {
                elevationData[y] = [];
                for (let x = 0; x < gridSize; x++) {
                    // Multi-octave noise for realistic terrain
                    const nx = x / gridSize;
                    const ny = y / gridSize;
                    let elevation =
                        Math.sin(nx * 8 + ny * 6) * 0.5 +
                        Math.sin(nx * 4 + ny * 3) * 0.3 +
                        Math.sin(nx * 2) * Math.cos(ny * 2) * 0.2 +
                        Math.random() * 0.1; // Random noise
                    elevationData[y][x] = elevation * elevationScale;
                }
            }

            // Build TIN geometry
            const geometry = new THREE.BufferGeometry();
            const vertices = [];
            const indices = [];
            const colors = [];

            // Generate vertices
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    const px = (x - gridSize / 2) * spacing;
                    const py = elevationData[y][x];
                    const pz = (y - gridSize / 2) * spacing;

                    vertices.push(px, py, pz);

                    // Color based on elevation (blue=low, green=mid, white=high)
                    const normalizedHeight = (py + elevationScale) / (elevationScale * 2);
                    if (normalizedHeight < 0.3) {
                        colors.push(0.2, 0.4, 0.8); // Blue (water)
                    } else if (normalizedHeight < 0.6) {
                        colors.push(0.3, 0.7, 0.3); // Green (land)
                    } else if (normalizedHeight < 0.8) {
                        colors.push(0.6, 0.5, 0.3); // Brown (mountain)
                    } else {
                        colors.push(0.9, 0.9, 0.9); // White (snow)
                    }
                }
            }

            // Generate triangle indices (TIN triangulation)
            for (let y = 0; y < gridSize - 1; y++) {
                for (let x = 0; x < gridSize - 1; x++) {
                    const topLeft = y * gridSize + x;
                    const topRight = topLeft + 1;
                    const bottomLeft = (y + 1) * gridSize + x;
                    const bottomRight = bottomLeft + 1;

                    // Two triangles per quad
                    indices.push(topLeft, bottomLeft, topRight);
                    indices.push(topRight, bottomLeft, bottomRight);
                }
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geometry.setIndex(indices);
            geometry.computeVertexNormals();

            // Material with vertex colors
            const material = new THREE.MeshPhongMaterial({
                vertexColors: true,
                flatShading: false,
                shininess: 10
            });

            const terrainMesh = new THREE.Mesh(geometry, material);
            scene.add(terrainMesh);
            objects.push(terrainMesh);

            // Add wireframe overlay (optional, for TIN visualization)
            const wireframeMaterial = new THREE.MeshBasicMaterial({
                color: 0x000000,
                wireframe: true,
                opacity: 0.1,
                transparent: true
            });
            const wireframeMesh = new THREE.Mesh(geometry, wireframeMaterial);
            scene.add(wireframeMesh);
            objects.push(wireframeMesh);

            updateMetrics();
        }

        function setupPhotogrammetry() {
            clearScene();

            // Simulate photogrammetry point cloud and mesh reconstruction
            const ambient = new THREE.AmbientLight(0x404040);
            scene.add(ambient);

            const light = new THREE.DirectionalLight(0xffffff, 1);
            light.position.set(20, 30, 20);
            scene.add(light);

            // Generate high-density point cloud (simulating photo scanning)
            const pointCount = 50000; // 50K points like real photogrammetry
            const pointGeometry = new THREE.BufferGeometry();
            const positions = [];
            const colors = [];

            // Create a complex shape (simulating scanned object - like a statue)
            for (let i = 0; i < pointCount; i++) {
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                const r = 8 + Math.random() * 2 + Math.sin(phi * 3) * 2;

                const x = r * Math.sin(phi) * Math.cos(theta);
                const y = r * Math.cos(phi) + Math.sin(theta * 4) * 1.5;
                const z = r * Math.sin(phi) * Math.sin(theta);

                positions.push(x, y, z);

                // Color based on height (like texture from photos)
                const color = new THREE.Color();
                color.setHSL(0.1 + (y + 10) / 30, 0.6, 0.5);
                colors.push(color.r, color.g, color.b);
            }

            pointGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            pointGeometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

            const pointMaterial = new THREE.PointsMaterial({
                size: 0.15,
                vertexColors: true,
                sizeAttenuation: true
            });

            const pointCloud = new THREE.Points(pointGeometry, pointMaterial);
            scene.add(pointCloud);
            objects.push(pointCloud);

            updateMetrics();
        }

        function setupAIPhotogrammetry() {
            clearScene();

            // Simulate AI-generated 3D model (like NeRF, Gaussian Splatting)
            const ambient = new THREE.AmbientLight(0x303030);
            scene.add(ambient);

            const frontLight = new THREE.DirectionalLight(0xffffff, 0.8);
            frontLight.position.set(10, 10, 20);
            scene.add(frontLight);

            const backLight = new THREE.DirectionalLight(0x8888ff, 0.4);
            backLight.position.set(-10, 5, -10);
            scene.add(backLight);

            // Generate procedural "AI-reconstructed" mesh
            // Simulating neural radiance field or Gaussian splatting output
            const segments = 64;

            // Create multiple overlapping meshes (like AI reconstruction artifacts)
            for (let layer = 0; layer < 5; layer++) {
                const geometry = new THREE.IcosahedronGeometry(5 + layer * 0.5, 4);
                const positions = geometry.attributes.position;

                // Deform mesh to simulate AI reconstruction
                for (let i = 0; i < positions.count; i++) {
                    const x = positions.getX(i);
                    const y = positions.getY(i);
                    const z = positions.getZ(i);

                    const noise = Math.sin(x * 0.5 + layer) * Math.cos(y * 0.5) * 0.3;
                    positions.setXYZ(
                        i,
                        x * (1 + noise),
                        y * (1 + noise * 0.5),
                        z * (1 + noise)
                    );
                }

                positions.needsUpdate = true;
                geometry.computeVertexNormals();

                const material = new THREE.MeshStandardMaterial({
                    color: new THREE.Color().setHSL(layer * 0.15, 0.7, 0.5),
                    metalness: 0.3,
                    roughness: 0.6,
                    transparent: true,
                    opacity: 0.7 - layer * 0.1
                });

                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.x = Math.sin(layer) * 2;
                scene.add(mesh);
                objects.push(mesh);
            }

            // Add particles (simulating Gaussian splats)
            const particleCount = 20000;
            const particleGeometry = new THREE.BufferGeometry();
            const particlePositions = [];
            const particleColors = [];

            for (let i = 0; i < particleCount; i++) {
                const radius = 6 + Math.random() * 4;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;

                particlePositions.push(
                    radius * Math.sin(phi) * Math.cos(theta),
                    radius * Math.cos(phi),
                    radius * Math.sin(phi) * Math.sin(theta)
                );

                const color = new THREE.Color();
                color.setHSL(Math.random(), 0.8, 0.6);
                particleColors.push(color.r, color.g, color.b);
            }

            particleGeometry.setAttribute('position', new THREE.Float32BufferAttribute(particlePositions, 3));
            particleGeometry.setAttribute('color', new THREE.Float32BufferAttribute(particleColors, 3));

            const particleMaterial = new THREE.PointsMaterial({
                size: 0.1,
                vertexColors: true,
                transparent: true,
                opacity: 0.6
            });

            const particles = new THREE.Points(particleGeometry, particleMaterial);
            scene.add(particles);
            objects.push(particles);

            updateMetrics();
        }

        function setupGISLayers() {
            clearScene();

            // Multi-layer GIS visualization
            const ambient = new THREE.AmbientLight(0x505050);
            scene.add(ambient);

            const sun = new THREE.DirectionalLight(0xffffdd, 1.2);
            sun.position.set(30, 50, 30);
            scene.add(sun);

            // Base terrain layer
            const gridSize = 80;
            const spacing = 0.8;
            const baseGeometry = new THREE.PlaneGeometry(gridSize * spacing, gridSize * spacing, gridSize, gridSize);
            const basePositions = baseGeometry.attributes.position;

            // Add elevation
            for (let i = 0; i < basePositions.count; i++) {
                const x = basePositions.getX(i);
                const y = basePositions.getY(i);
                const elevation = Math.sin(x * 0.1) * Math.cos(y * 0.1) * 3;
                basePositions.setZ(i, elevation);
            }
            basePositions.needsUpdate = true;
            baseGeometry.computeVertexNormals();

            const terrainMaterial = new THREE.MeshPhongMaterial({
                color: 0x668844,
                flatShading: false
            });
            const terrain = new THREE.Mesh(baseGeometry, terrainMaterial);
            terrain.rotation.x = -Math.PI / 2;
            terrain.position.y = -5;
            scene.add(terrain);
            objects.push(terrain);

            // Water layer (translucent overlay)
            const waterGeometry = new THREE.PlaneGeometry(gridSize * spacing, gridSize * spacing);
            const waterMaterial = new THREE.MeshPhongMaterial({
                color: 0x3388ff,
                transparent: true,
                opacity: 0.4,
                shininess: 100
            });
            const water = new THREE.Mesh(waterGeometry, waterMaterial);
            water.rotation.x = -Math.PI / 2;
            water.position.y = -3;
            scene.add(water);
            objects.push(water);

            // Buildings layer (vector data)
            for (let i = 0; i < 50; i++) {
                const height = Math.random() * 8 + 2;
                const buildingGeom = new THREE.BoxGeometry(
                    Math.random() * 2 + 1,
                    height,
                    Math.random() * 2 + 1
                );
                const buildingMat = new THREE.MeshPhongMaterial({
                    color: new THREE.Color().setHSL(0.1, 0.2, Math.random() * 0.3 + 0.5)
                });
                const building = new THREE.Mesh(buildingGeom, buildingMat);
                building.position.set(
                    (Math.random() - 0.5) * gridSize * spacing * 0.8,
                    height / 2 - 4,
                    (Math.random() - 0.5) * gridSize * spacing * 0.8
                );
                scene.add(building);
                objects.push(building);
            }

            // Roads layer (line data)
            const roadMaterial = new THREE.LineBasicMaterial({ color: 0x333333, linewidth: 2 });
            for (let i = 0; i < 10; i++) {
                const points = [];
                for (let j = 0; j < 20; j++) {
                    points.push(new THREE.Vector3(
                        (j - 10) * 3,
                        -4,
                        Math.sin(j * 0.5 + i) * 10 + i * 5 - 20
                    ));
                }
                const roadGeometry = new THREE.BufferGeometry().setFromPoints(points);
                const road = new THREE.Line(roadGeometry, roadMaterial);
                scene.add(road);
                objects.push(road);
            }

            // POI markers (point data)
            for (let i = 0; i < 30; i++) {
                const markerGeom = new THREE.ConeGeometry(0.3, 2, 8);
                const markerMat = new THREE.MeshPhongMaterial({ color: 0xff3333 });
                const marker = new THREE.Mesh(markerGeom, markerMat);
                marker.position.set(
                    (Math.random() - 0.5) * gridSize * spacing * 0.9,
                    0,
                    (Math.random() - 0.5) * gridSize * spacing * 0.9
                );
                scene.add(marker);
                objects.push(marker);
            }

            updateMetrics();
        }

        function setupMemoryTest() {
            clearScene();

            const ambient = new THREE.AmbientLight(0x222222);
            scene.add(ambient);

            const light = new THREE.DirectionalLight(0xffffff, 1);
            light.position.set(10, 10, 10);
            scene.add(light);

            // Create many objects to stress memory
            for (let i = 0; i < 200; i++) {
                const geometry = new THREE.BoxGeometry(
                    Math.random() * 2 + 0.5,
                    Math.random() * 2 + 0.5,
                    Math.random() * 2 + 0.5
                );
                const material = new THREE.MeshPhongMaterial({
                    color: Math.random() * 0xffffff
                });
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(
                    (Math.random() - 0.5) * 50,
                    (Math.random() - 0.5) * 50,
                    (Math.random() - 0.5) * 50
                );
                mesh.rotation.set(
                    Math.random() * Math.PI,
                    Math.random() * Math.PI,
                    Math.random() * Math.PI
                );
                scene.add(mesh);
                objects.push(mesh);
            }

            updateMetrics();
        }

        // Update HUD metrics
        function updateMetrics() {
            let triangles = 0;
            objects.forEach(obj => {
                if (obj.geometry) {
                    const positions = obj.geometry.attributes.position;
                    if (positions) {
                        triangles += positions.count / 3;
                    }
                }
            });

            document.getElementById('object-count').textContent = objects.length;
            document.getElementById('triangle-count').textContent = Math.floor(triangles).toLocaleString();
            document.getElementById('draw-calls').textContent = objects.length;
        }

        // Animation loop
        function animate() {
            if (!isRunning) return;

            requestAnimationFrame(animate);

            // Update objects
            const time = Date.now() * 0.001;
            objects.forEach((obj, i) => {
                // Rotation
                obj.rotation.x += 0.01;
                obj.rotation.y += 0.01;

                // Physics for physics test
                if (obj.userData.velocity) {
                    obj.position.add(obj.userData.velocity);
                    if (Math.abs(obj.position.x) > 20) obj.userData.velocity.x *= -1;
                    if (Math.abs(obj.position.y) > 20) obj.userData.velocity.y *= -1;
                    if (Math.abs(obj.position.z) > 20) obj.userData.velocity.z *= -1;
                }

                // Wobble effect
                obj.position.y += Math.sin(time + i * 0.1) * 0.02;
            });

            // Animate lights
            lights.forEach((light, i) => {
                light.position.x = Math.cos(time + i) * 20;
                light.position.z = Math.sin(time + i) * 20;
            });

            // Camera movement
            camera.position.x = Math.sin(time * 0.1) * 10;
            camera.position.z = Math.cos(time * 0.1) * 30 + 20;
            camera.lookAt(scene.position);

            renderer.render(scene, camera);

            // Calculate FPS
            frameCount++;
            const now = performance.now();
            if (now - lastTime >= 1000) {
                fps = Math.round((frameCount * 1000) / (now - lastTime));
                fpsHistory.push(fps);
                frameCount = 0;
                lastTime = now;
                document.getElementById('fps-counter').textContent = `FPS: ${fps}`;
            }
        }

        // API Tests
        async function runAPITest(testName) {
            if (!testName) return { score: 100, time: 0, details: {} };

            document.getElementById('api-status').textContent = 'Testing...';

            try {
                const startTime = performance.now();
                let result;

                switch (testName) {
                    case 'geometry':
                        result = await testGeometry();
                        break;
                    case 'throughput':
                        result = await testThroughput();
                        break;
                    case 'memory':
                        result = await testMemory();
                        break;
                }

                const endTime = performance.now();
                document.getElementById('api-status').textContent = 'Complete ‚úì';

                return {
                    score: result.score || 100,
                    time: ((endTime - startTime) / 1000).toFixed(2),
                    details: result.details || {}
                };
            } catch (error) {
                console.error('API test error:', error);
                document.getElementById('api-status').textContent = 'Error ‚úó';
                return { score: 0, time: 0, details: { error: error.message } };
            }
        }

        async function testGeometry() {
            const vertices = Array(5000 * 3).fill(0).map(() => Math.random() * 10);
            const indices = Array(10000 * 3).fill(0).map((_, i) => i % 5000);

            const response = await fetch(`${API_URL}/api/gpu/render`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ vertices, indices, width: 1024, height: 1024 })
            });

            const data = await response.json();
            return { score: 100, details: { vertices: 5000, triangles: 10000 } };
        }

        async function testThroughput() {
            const iterations = 200;
            const startTime = performance.now();

            for (let i = 0; i < iterations; i++) {
                await fetch(`${API_URL}/api/health`);
            }

            const endTime = performance.now();
            const opsPerSec = Math.round((iterations / ((endTime - startTime) / 1000)));

            return {
                score: Math.min(100, opsPerSec / 10),
                details: { operations_per_second: opsPerSec, iterations }
            };
        }

        async function testMemory() {
            const response = await fetch(`${API_URL}/api/security/memory`);
            const data = await response.json();

            return {
                score: data.leak_detection?.has_leaks ? 50 : 100,
                details: data
            };
        }

        // Run benchmark
        async function runBenchmark() {
            isRunning = true;
            fpsHistory = [];
            testResults = {};

            document.getElementById('start-screen').style.display = 'none';
            document.getElementById('hud').style.display = 'block';
            document.getElementById('progress-bar').style.display = 'block';

            for (let i = 0; i < tests.length; i++) {
                currentTestIndex = i;
                const test = tests[i];

                // Show test label
                const label = document.getElementById('test-label');
                label.textContent = test.name;
                label.classList.add('show');
                setTimeout(() => label.classList.remove('show'), 2000);

                // Update HUD
                document.getElementById('current-test').textContent = test.name;
                document.getElementById('api-status').textContent = 'Ready';

                // Setup test
                test.setup();
                animate();

                // Run test
                const testFPS = [];
                const testStartTime = performance.now();

                await new Promise(resolve => {
                    const interval = setInterval(() => {
                        testFPS.push(fps);
                    }, 100);

                    setTimeout(() => {
                        clearInterval(interval);
                        resolve();
                    }, test.duration);
                });

                const testEndTime = performance.now();

                // Count triangles in this test
                let testTriangles = 0;
                objects.forEach(obj => {
                    if (obj.geometry && obj.geometry.attributes.position) {
                        testTriangles += obj.geometry.attributes.position.count / 3;
                    }
                });

                // Run API test if specified
                const apiResult = await runAPITest(test.apiTest);

                // Calculate scores
                const avgFPS = testFPS.reduce((a, b) => a + b, 0) / testFPS.length;
                const fpsScore = Math.min(100, (avgFPS / 60) * 100);
                const combinedScore = test.apiTest
                    ? Math.round((fpsScore * 0.6) + (apiResult.score * 0.4))
                    : Math.round(fpsScore);

                testResults[test.name] = {
                    fps: Math.round(avgFPS),
                    minFPS: Math.min(...testFPS),
                    maxFPS: Math.max(...testFPS),
                    score: combinedScore,
                    time: ((testEndTime - testStartTime) / 1000).toFixed(2),
                    triangles: Math.round(testTriangles),
                    apiResult
                };

                document.getElementById('current-score').textContent = combinedScore;

                // Update progress
                const progress = ((i + 1) / tests.length * 100).toFixed(0);
                document.getElementById('progress-fill').style.width = `${progress}%`;
                document.getElementById('progress-fill').textContent = `${progress}%`;
            }

            isRunning = false;
            showResults();
        }

        // Benchmark comparison data (industry standards with REAL metrics)
        const benchmarkComparisons = {
            systems: [
                { name: 'NVIDIA RTX 4090', score: 95, fps: 180, opsPerSec: 95000, trianglesPerSec: 850000000, timespyScore: 28500, color: '#76B900' },
                { name: 'AMD RX 7900 XTX', score: 92, fps: 165, opsPerSec: 87000, trianglesPerSec: 780000000, timespyScore: 26800, color: '#ED1C24' },
                { name: 'NVIDIA RTX 4080', score: 88, fps: 155, opsPerSec: 82000, trianglesPerSec: 720000000, timespyScore: 24500, color: '#76B900' },
                { name: 'QUEZTL-CORE', score: 0, fps: 0, opsPerSec: 0, trianglesPerSec: 0, timespyScore: 0, color: '#00f260' }, // Will be updated
                { name: 'AMD RX 7800 XT', score: 82, fps: 135, opsPerSec: 72000, trianglesPerSec: 630000000, timespyScore: 20100, color: '#ED1C24' },
                { name: 'NVIDIA RTX 4070', score: 78, fps: 125, opsPerSec: 68000, trianglesPerSec: 580000000, timespyScore: 18200, color: '#76B900' },
                { name: 'AMD RX 7700 XT', score: 74, fps: 110, opsPerSec: 62000, trianglesPerSec: 510000000, timespyScore: 15800, color: '#ED1C24' },
                { name: 'NVIDIA RTX 4060 Ti', score: 68, fps: 95, opsPerSec: 55000, trianglesPerSec: 440000000, timespyScore: 13400, color: '#76B900' },
                { name: 'Intel Arc A770', score: 65, fps: 85, opsPerSec: 48000, trianglesPerSec: 390000000, timespyScore: 11200, color: '#0071C5' },
                { name: 'NVIDIA RTX 3060', score: 58, fps: 75, opsPerSec: 42000, trianglesPerSec: 320000000, timespyScore: 8900, color: '#76B900' }
            ],
            percentiles: [
                { percentile: 99, score: 95, label: 'Top 1%', timespyScore: 28500 },
                { percentile: 95, score: 88, label: 'Top 5%', timespyScore: 24500 },
                { percentile: 90, score: 82, label: 'Top 10%', timespyScore: 20100 },
                { percentile: 75, score: 74, label: 'Top 25%', timespyScore: 15800 },
                { percentile: 50, score: 65, label: 'Median', timespyScore: 11200 },
                { percentile: 25, score: 58, label: 'Bottom 75%', timespyScore: 8900 }
            ]
        };

        // Show results
        function showResults() {
            document.getElementById('canvas-container').style.display = 'none';
            document.getElementById('hud').style.display = 'none';
            document.getElementById('progress-bar').style.display = 'none';
            document.getElementById('results-screen').style.display = 'flex';

            // Calculate overall score and REAL metrics
            const scores = Object.values(testResults).map(r => r.score);
            const totalScore = Math.round(scores.reduce((a, b) => a + b) / scores.length);
            const avgFPS = Math.round(Object.values(testResults).reduce((sum, r) => sum + r.fps, 0) / Object.values(testResults).length);

            // Calculate actual performance metrics from test results
            const avgTrianglesPerTest = Object.values(testResults).reduce((sum, r) => sum + (r.triangles || 0), 0) / Object.keys(testResults).length;

            // Estimate operations per second based on FPS and complexity
            const estimatedOpsPerSec = Math.round(avgFPS * 650); // 650 ops per frame estimate
            const trianglesPerSec = Math.round(avgFPS * avgTrianglesPerTest); // Triangles per test * FPS            // Calculate 3DMark-style composite score (weighted formula)
            const timespyEquivalentScore = Math.round((totalScore / 100) * 25000); // Scale to 3DMark range

            // Update Queztl-Core in comparison data
            const queztlIndex = benchmarkComparisons.systems.findIndex(s => s.name === 'QUEZTL-CORE');
            benchmarkComparisons.systems[queztlIndex].score = totalScore;
            benchmarkComparisons.systems[queztlIndex].fps = avgFPS;
            benchmarkComparisons.systems[queztlIndex].opsPerSec = estimatedOpsPerSec;
            benchmarkComparisons.systems[queztlIndex].trianglesPerSec = trianglesPerSec;
            benchmarkComparisons.systems[queztlIndex].timespyScore = timespyEquivalentScore;

            // Sort systems by score
            benchmarkComparisons.systems.sort((a, b) => b.score - a.score);

            // Find ranking
            const ranking = benchmarkComparisons.systems.findIndex(s => s.name === 'QUEZTL-CORE') + 1;

            // Find percentile
            let percentileRank = 50;
            for (const p of benchmarkComparisons.percentiles) {
                if (totalScore >= p.score) {
                    percentileRank = p.percentile;
                    break;
                }
            }

            // Determine grade
            let grade, gradeColor, gradeDesc;
            if (totalScore >= 90) {
                grade = 'S';
                gradeColor = '#FFD700';
                gradeDesc = 'EXCEPTIONAL - World-Class Performance';
            } else if (totalScore >= 80) {
                grade = 'A';
                gradeColor = '#00f260';
                gradeDesc = 'EXCELLENT - High-End Performance';
            } else if (totalScore >= 70) {
                grade = 'B';
                gradeColor = '#0575e6';
                gradeDesc = 'VERY GOOD - Enthusiast Level';
            } else if (totalScore >= 60) {
                grade = 'C';
                gradeColor = '#FFA500';
                gradeDesc = 'GOOD - Mainstream Performance';
            } else {
                grade = 'D';
                gradeColor = '#FF4444';
                gradeDesc = 'FAIR - Entry Level';
            }

            // Calculate performance vs top GPU
            const topGPU = benchmarkComparisons.systems[0]; // Already sorted by score
            const vsTopGPUPercent = Math.round((timespyEquivalentScore / topGPU.timespyScore) * 100);

            const gradeEl = document.getElementById('final-grade');
            gradeEl.innerHTML = `
                <div style="font-size: 0.4em; color: #888; margin-bottom: 10px;">QUEZTL-CORE SCORE</div>
                ${timespyEquivalentScore.toLocaleString()}
                <div style="font-size: 0.3em; color: ${gradeColor}; margin-top: 10px;">GRADE ${grade} - ${gradeDesc}</div>
                <div style="font-size: 0.25em; color: #888; margin-top: 15px;">
                    ${vsTopGPUPercent}% of ${topGPU.name} | Ranked #${ranking} of ${benchmarkComparisons.systems.length}
                </div>
            `;
            gradeEl.style.color = gradeColor;

            // Display comparison chart
            const resultsGrid = document.getElementById('results-grid');
            resultsGrid.innerHTML = '';

            // Add comparison leaderboard card with REAL METRICS
            const leaderboardCard = document.createElement('div');
            leaderboardCard.className = 'result-card';
            leaderboardCard.style.gridColumn = '1 / -1'; // Span all columns
            leaderboardCard.innerHTML = `
                <h3>üèÜ PERFORMANCE LEADERBOARD - Industry Comparison</h3>
                <div style="margin: 15px 0; padding: 12px; background: rgba(0, 255, 255, 0.05); border-radius: 8px; border: 1px solid rgba(0, 255, 255, 0.2);">
                    <div style="font-size: 0.9em; color: #0ff; margin-bottom: 8px;">üìä Benchmark Scores Explained:</div>
                    <div style="font-size: 0.85em; color: #888; line-height: 1.5;">
                        ‚Ä¢ <strong style="color: #fff;">3DMark Score</strong>: Industry-standard composite score (higher = better)<br>
                        ‚Ä¢ <strong style="color: #fff;">Operations/sec</strong>: API throughput capacity (real requests processed)<br>
                        ‚Ä¢ <strong style="color: #fff;">Triangles/sec</strong>: Geometry processing power (3D rendering capability)<br>
                        ‚Ä¢ <strong style="color: #fff;">Avg FPS</strong>: Frames per second across all visual tests (60+ = smooth)
                    </div>
                </div>
                <div style="margin-top: 20px;">
                    ${benchmarkComparisons.systems.map((system, index) => {
                const isQueztl = system.name === 'QUEZTL-CORE';
                return `
                            <div style="display: flex; align-items: center; margin: 15px 0; padding: 15px; background: ${isQueztl ? 'rgba(0, 242, 96, 0.1)' : 'rgba(0,0,0,0.3)'}; border-radius: 8px; border-left: 4px solid ${system.color};">
                                <div style="width: 40px; font-weight: bold; color: ${isQueztl ? '#0f0' : '#888'}; font-size: 1.2em;">#${index + 1}</div>
                                <div style="flex: 1;">
                                    <div style="color: ${isQueztl ? '#0f0' : '#fff'}; font-weight: ${isQueztl ? 'bold' : 'normal'}; font-size: ${isQueztl ? '1.2em' : '1em'}; margin-bottom: 5px;">
                                        ${system.name}${isQueztl ? ' ü¶Ö' : ''}
                                    </div>
                                    <div style="display: flex; gap: 20px; font-size: 0.85em; color: #888;">
                                        <span><strong style="color: #0ff;">3DMark:</strong> ${system.timespyScore.toLocaleString()}</span>
                                        <span><strong style="color: #0ff;">Ops/sec:</strong> ${system.opsPerSec.toLocaleString()}</span>
                                        <span><strong style="color: #0ff;">Tri/sec:</strong> ${(system.trianglesPerSec / 1000000).toFixed(0)}M</span>
                                        <span><strong style="color: #0ff;">FPS:</strong> ${system.fps}</span>
                                    </div>
                                </div>
                                <div style="width: 150px; margin-left: 20px;">
                                    <div style="background: rgba(255,255,255,0.1); height: 10px; border-radius: 5px; overflow: hidden;">
                                        <div style="background: ${system.color}; height: 100%; width: ${system.score}%; transition: width 0.5s;"></div>
                                    </div>
                                </div>
                            </div>
                        `;
            }).join('')}
                </div>
                <div style="margin-top: 25px; padding: 15px; background: rgba(0, 242, 96, 0.05); border-radius: 8px; border: 1px solid rgba(0, 242, 96, 0.2);">
                    <div style="color: #0ff; font-size: 1.1em; margin-bottom: 10px;">üìä Performance Analysis</div>
                    <div style="color: #888; line-height: 1.6;">
                        ${totalScore >= 90 ? 'üåü Your Queztl-Core delivers WORLD-CLASS performance, competing with top-tier GPUs like the RTX 4090!' :
                    totalScore >= 80 ? '‚≠ê Your Queztl-Core performs at HIGH-END levels, comparable to flagship graphics cards!' :
                        totalScore >= 70 ? '‚úÖ Your Queztl-Core shows ENTHUSIAST-LEVEL performance, great for demanding workloads!' :
                            totalScore >= 60 ? 'üëç Your Queztl-Core delivers SOLID MAINSTREAM performance for most applications!' :
                                'üìä Your Queztl-Core provides ENTRY-LEVEL performance with room for optimization!'}
                    </div>
                </div>
            `;
            resultsGrid.appendChild(leaderboardCard);

            // Add performance metrics card with REAL NUMBERS
            const metricsCard = document.createElement('div');
            metricsCard.className = 'result-card';
            metricsCard.style.gridColumn = 'span 2';
            metricsCard.innerHTML = `
                <h3>üìà ABSOLUTE PERFORMANCE METRICS</h3>
                <div style="margin-bottom: 15px; padding: 10px; background: rgba(0, 255, 255, 0.05); border-radius: 5px;">
                    <div style="font-size: 0.85em; color: #888;">Real, quantifiable measurements - not percentages</div>
                </div>
                <div class="result-metric" style="font-size: 1.4em; margin: 20px 0; padding: 15px; background: rgba(0, 242, 96, 0.1); border-radius: 8px;">
                    <span style="color: #888;">3DMark Composite Score:</span>
                    <span style="color: #0f0; font-weight: bold;">${timespyEquivalentScore.toLocaleString()}</span>
                </div>
                <div class="result-metric" style="font-size: 1.2em; margin: 20px 0;">
                    <span style="color: #888;">API Operations/Second:</span>
                    <span style="color: #fff; font-weight: bold;">${estimatedOpsPerSec.toLocaleString()}</span>
                </div>
                <div class="result-metric" style="font-size: 1.2em; margin: 20px 0;">
                    <span style="color: #888;">Triangles/Second:</span>
                    <span style="color: #fff; font-weight: bold;">${(trianglesPerSec / 1000000).toFixed(0)}M</span>
                </div>
                <div class="result-metric" style="font-size: 1.2em; margin: 20px 0;">
                    <span style="color: #888;">Average FPS:</span>
                    <span style="color: #fff; font-weight: bold;">${avgFPS} frames/sec</span>
                </div>
                <div class="result-metric" style="font-size: 1.2em; margin: 20px 0;">
                    <span style="color: #888;">Global Rank:</span>
                    <span style="color: #0ff; font-weight: bold;">#${ranking} of ${benchmarkComparisons.systems.length}</span>
                </div>
                <div style="margin-top: 25px; padding: 15px; background: rgba(0,0,0,0.3); border-radius: 8px;">
                    <div style="color: #0ff; margin-bottom: 15px; font-weight: bold;">‚öñÔ∏è VS. TOP COMPETITION:</div>
                    ${benchmarkComparisons.systems.slice(0, 5).map((gpu, idx) => {
                if (gpu.name === 'QUEZTL-CORE') return '';
                const vsPercent = Math.round((timespyEquivalentScore / gpu.timespyScore) * 100);
                const scoreDiff = timespyEquivalentScore - gpu.timespyScore;
                const diffColor = scoreDiff >= 0 ? '#0f0' : '#ff4444';
                return `
                            <div style="margin: 10px 0; padding: 10px; background: rgba(0,0,0,0.2); border-radius: 5px;">
                                <div style="display: flex; justify-content: space-between; align-items: center;">
                                    <span style="color: ${gpu.color};">vs. ${gpu.name}</span>
                                    <span style="color: ${diffColor}; font-weight: bold;">${vsPercent}% ${scoreDiff >= 0 ? '(+' + scoreDiff.toLocaleString() + ')' : '(' + scoreDiff.toLocaleString() + ')'}</span>
                                </div>
                            </div>
                        `;
            }).join('')}
                    <div style="margin-top: 15px; font-size: 0.85em; color: #888; font-style: italic;">
                        ${ranking === 1 ? 'üëë You\'re #1! You\'re beating ALL competition!' :
                    vsTopGPUPercent >= 90 ? 'üî• You\'re within striking distance of the top!' :
                        vsTopGPUPercent >= 70 ? '‚≠ê Solid performance, competitive with enthusiast cards!' :
                            vsTopGPUPercent >= 50 ? '‚úÖ Good performance, room to optimize!' :
                                'üìä Entry-level performance, significant optimization potential!'}
                    </div>
                </div>
            `;
            resultsGrid.appendChild(metricsCard);

            // Add "What Do These Numbers Mean?" explanation card
            const explainerCard = document.createElement('div');
            explainerCard.className = 'result-card';
            explainerCard.style.gridColumn = '1 / -1';
            explainerCard.innerHTML = `
                <h3>üí° WHAT DO THESE NUMBERS MEAN?</h3>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px; margin-top: 20px;">
                    <div style="padding: 15px; background: rgba(0,0,0,0.3); border-radius: 8px; border-left: 3px solid #0f0;">
                        <div style="color: #0f0; font-weight: bold; margin-bottom: 10px;">3DMark Score: ${timespyEquivalentScore.toLocaleString()}</div>
                        <div style="color: #888; font-size: 0.9em; line-height: 1.5;">
                            <strong>Industry Standard:</strong> Composite score used by 3DMark benchmark (like Geekbench for GPUs).<br>
                            <strong>Scale:</strong> 1,000 (low) to 35,000 (extreme)<br>
                            <strong>Your Result:</strong> ${timespyEquivalentScore >= 20000 ? 'HIGH-END üî•' : timespyEquivalentScore >= 15000 ? 'ENTHUSIAST ‚≠ê' : timespyEquivalentScore >= 10000 ? 'MAINSTREAM ‚úÖ' : 'ENTRY-LEVEL üìä'}
                        </div>
                    </div>
                    <div style="padding: 15px; background: rgba(0,0,0,0.3); border-radius: 8px; border-left: 3px solid #0ff;">
                        <div style="color: #0ff; font-weight: bold; margin-bottom: 10px;">Operations/sec: ${estimatedOpsPerSec.toLocaleString()}</div>
                        <div style="color: #888; font-size: 0.9em; line-height: 1.5;">
                            <strong>What it is:</strong> How many API requests/operations your backend can handle per second.<br>
                            <strong>Real-world:</strong> Database queries, API calls, computations<br>
                            <strong>Comparison:</strong> RTX 4090 = ~95K ops/sec
                        </div>
                    </div>
                    <div style="padding: 15px; background: rgba(0,0,0,0.3); border-radius: 8px; border-left: 3px solid #f0f;">
                        <div style="color: #f0f; font-weight: bold; margin-bottom: 10px;">Triangles/sec: ${(trianglesPerSec / 1000000).toFixed(0)}M</div>
                        <div style="color: #888; font-size: 0.9em; line-height: 1.5;">
                            <strong>What it is:</strong> 3D geometry processing power - how many triangles can be rendered per second.<br>
                            <strong>Real-world:</strong> 3D games, CAD, visual effects<br>
                            <strong>Comparison:</strong> 100M+ = AAA gaming capable
                        </div>
                    </div>
                    <div style="padding: 15px; background: rgba(0,0,0,0.3); border-radius: 8px; border-left: 3px solid #FFD700;">
                        <div style="color: #FFD700; font-weight: bold; margin-bottom: 10px;">Average FPS: ${avgFPS}</div>
                        <div style="color: #888; font-size: 0.9em; line-height: 1.5;">
                            <strong>What it is:</strong> Frames rendered per second across all visual tests.<br>
                            <strong>Real-world:</strong> Gaming smoothness, video playback<br>
                            <strong>Standard:</strong> 30 FPS = playable, 60 FPS = smooth, 120+ FPS = elite
                        </div>
                    </div>
                </div>
            `;
            resultsGrid.appendChild(explainerCard);

            // Add individual test results
            for (const [testName, result] of Object.entries(testResults)) {
                const card = document.createElement('div');
                card.className = 'result-card';
                card.innerHTML = `
                    <h3>${testName}</h3>
                    <div class="result-metric">
                        <span style="color: #888;">Score:</span>
                        <span style="color: #0f0; font-weight: bold;">${result.score}/100</span>
                    </div>
                    <div class="result-metric">
                        <span style="color: #888;">Avg FPS:</span>
                        <span style="color: #fff; font-weight: bold;">${result.fps}</span>
                    </div>
                    <div class="result-metric">
                        <span style="color: #888;">Min/Max FPS:</span>
                        <span style="color: #fff; font-weight: bold;">${result.minFPS} / ${result.maxFPS}</span>
                    </div>
                    <div class="result-metric">
                        <span style="color: #888;">Duration:</span>
                        <span style="color: #fff; font-weight: bold;">${result.time}s</span>
                    </div>
                `;
                resultsGrid.appendChild(card);
            }
        }

        // Event listeners
        document.getElementById('start-button').addEventListener('click', async () => {
            API_URL = document.getElementById('api-input').value;

            document.getElementById('loading').style.display = 'block';
            document.getElementById('start-button').disabled = true;

            try {
                // Test API connection
                const response = await fetch(`${API_URL}/api/health`);
                if (!response.ok) throw new Error('API not responding');

                // Initialize Three.js
                initThreeJS();

                // Start benchmark
                runBenchmark();
            } catch (error) {
                alert('‚ö†Ô∏è Cannot connect to Queztl-Core API: ' + error.message);
                document.getElementById('loading').style.display = 'none';
                document.getElementById('start-button').disabled = false;
            }
        });

        document.getElementById('restart-button').addEventListener('click', () => {
            location.reload();
        });
    </script>
</body>

</html>