#!/usr/bin/env python3
"""
ü¶Ö QUEZTL COMMAND LINE INTERFACE (qctl)

Unix/Linux style CLI for Queztl's unique architecture.

Commands organized like:
- qctl brain <subcommand>     - Brain operations
- qctl vm <subcommand>         - Hypervisor/VM operations  
- qctl node <subcommand>       - Node management
- qctl task <subcommand>       - Task submission
- qctl monitor                 - Real-time monitoring
- qctl deploy                  - Deployment operations

Think: kubectl for Kubernetes, but for Queztl's brain + hypervisor architecture
"""

import sys
import os
import asyncio
import json
import time
from typing import Optional, List, Dict
import argparse

sys.path.insert(0, '/Users/xavasena/hive')

from backend.queztl_brain import QueztlBrain, BrainControlledHypervisor
from backend.hypervisor.core import QueztlHypervisor, VMState


class QueztlCLI:
    """
    Queztl Command Line Interface
    
    Unix-style commands for brain + hypervisor architecture
    """
    
    def __init__(self):
        self.system = None
        self.config_path = os.path.expanduser("~/.queztl/config.json")
        self.history_path = os.path.expanduser("~/.queztl/history")
        
        # Ensure config directory exists
        os.makedirs(os.path.dirname(self.config_path), exist_ok=True)
        
        # Load or create config
        self.config = self._load_config()
    
    def _load_config(self) -> Dict:
        """Load CLI configuration"""
        if os.path.exists(self.config_path):
            with open(self.config_path, 'r') as f:
                return json.load(f)
        else:
            # Default config
            config = {
                "brain_endpoint": "local",
                "default_namespace": "default",
                "output_format": "text"  # text, json, yaml
            }
            self._save_config(config)
            return config
    
    def _save_config(self, config: Dict):
        """Save CLI configuration"""
        with open(self.config_path, 'w') as f:
            json.dump(config, f, indent=2)
    
    def _format_output(self, data: Dict, format_type: str = None):
        """Format output based on config"""
        format_type = format_type or self.config.get("output_format", "text")
        
        if format_type == "json":
            print(json.dumps(data, indent=2))
        elif format_type == "yaml":
            # Simple YAML output
            self._print_yaml(data)
        else:
            # Text format
            self._print_text(data)
    
    def _print_yaml(self, data: Dict, indent: int = 0):
        """Simple YAML printer"""
        for key, value in data.items():
            if isinstance(value, dict):
                print("  " * indent + f"{key}:")
                self._print_yaml(value, indent + 1)
            elif isinstance(value, list):
                print("  " * indent + f"{key}:")
                for item in value:
                    if isinstance(item, dict):
                        print("  " * (indent + 1) + "-")
                        self._print_yaml(item, indent + 2)
                    else:
                        print("  " * (indent + 1) + f"- {item}")
            else:
                print("  " * indent + f"{key}: {value}")
    
    def _print_text(self, data: Dict, indent: int = 0):
        """Print in readable text format"""
        for key, value in data.items():
            if isinstance(value, dict):
                print("  " * indent + f"{key}:")
                self._print_text(value, indent + 1)
            elif isinstance(value, list):
                print("  " * indent + f"{key}:")
                for item in value:
                    if isinstance(item, dict):
                        self._print_text(item, indent + 1)
                    else:
                        print("  " * (indent + 1) + f"‚Ä¢ {item}")
            else:
                print("  " * indent + f"{key}: {value}")
    
    async def _ensure_system(self):
        """Ensure brain system is initialized"""
        if self.system is None:
            print("üß† Connecting to Queztl Brain...")
            self.system = BrainControlledHypervisor()
            
            # Register local node if needed
            if not self.system.hypervisor.nodes:
                self.system.hypervisor.register_node(
                    "local",
                    vcpus=16,
                    memory_mb=32768
                )
            
            print("‚úÖ Connected to Queztl Brain")
    
    # ============================================================
    # BRAIN COMMANDS
    # ============================================================
    
    async def cmd_brain_status(self, args):
        """Show brain status: qctl brain status"""
        await self._ensure_system()
        
        status = self.system.brain.get_brain_status()
        
        if args.output:
            self._format_output(status, args.output)
        else:
            print("\nüß† QUEZTL BRAIN STATUS")
            print("=" * 50)
            print(f"Brain ID: {status['brain_id']}")
            print(f"Uptime: {status['uptime_seconds']:.0f}s")
            print(f"Mode: {'AUTONOMOUS' if status['autonomous_mode'] else 'MANUAL'}")
            print(f"Learning Rate: {status['learning_rate']}")
            print()
            print("METRICS:")
            print(f"  Tasks Completed: {status['metrics']['tasks_completed']}")
            print(f"  Decisions Made: {status['metrics']['decisions_made']}")
            print(f"  Optimizations: {status['metrics']['optimizations_applied']}")
            print(f"  Learning Cycles: {status['metrics']['learning_cycles']}")
            print()
            print(f"Experiences: {status['experiences_stored']} stored")
            print(f"Knowledge Domains: {status['knowledge_domains']}")
            print()
    
    async def cmd_brain_knowledge(self, args):
        """Show brain's learned knowledge: qctl brain knowledge"""
        await self._ensure_system()
        
        knowledge = self.system.brain.get_knowledge_summary()
        
        if args.output:
            self._format_output(knowledge, args.output)
        else:
            print("\nüìö BRAIN KNOWLEDGE BASE")
            print("=" * 50)
            
            if not knowledge:
                print("No learned knowledge yet.")
            else:
                for domain, stats in knowledge.items():
                    print(f"\n{domain}:")
                    print(f"  Success Rate: {stats['success_rate']:.1%}")
                    print(f"  Total Attempts: {stats['total_attempts']}")
                    print(f"  Avg Duration: {stats['avg_duration']:.1f}s")
            print()
    
    async def cmd_brain_optimize(self, args):
        """Trigger brain optimization: qctl brain optimize"""
        await self._ensure_system()
        
        print("üß† Running brain optimization...")
        optimizations = await self.system.brain.optimize_resources()
        
        print(f"‚úÖ Applied {len(optimizations)} optimizations")
        for opt in optimizations:
            print(f"  ‚Ä¢ {opt}")
        print()
    
    # ============================================================
    # VM COMMANDS
    # ============================================================
    
    async def cmd_vm_list(self, args):
        """List VMs: qctl vm list"""
        await self._ensure_system()
        
        vms = self.system.hypervisor.list_vms()
        
        if args.output:
            self._format_output({"vms": vms}, args.output)
        else:
            print("\nüñ•Ô∏è  VIRTUAL MACHINES")
            print("=" * 80)
            print(f"{'NAME':<25} {'STATE':<12} {'CPU':<6} {'MEMORY':<10} {'UPTIME':<10}")
            print("-" * 80)
            
            for vm in vms:
                uptime = f"{vm['uptime']:.0f}s" if vm['uptime'] > 0 else "-"
                print(f"{vm['name']:<25} {vm['state']:<12} {vm['vcpus']:<6} "
                      f"{vm['memory_mb']}MB{'':<6} {uptime:<10}")
            
            print(f"\nTotal: {len(vms)} VMs")
            print()
    
    async def cmd_vm_create(self, args):
        """Create a VM: qctl vm create <name> [options]"""
        await self._ensure_system()
        
        print(f"üîß Creating VM: {args.name}")
        
        # Let brain decide resources if not specified
        if not (args.cpu or args.memory):
            print("üß† Brain analyzing resource requirements...")
            decision = await self.system.brain.analyze_task(
                f"Create VM for {args.purpose or 'general compute'}"
            )
            vcpus = decision.resources_needed.get('vcpus', 2)
            memory = decision.resources_needed.get('memory_mb', 2048)
            vgpus = decision.resources_needed.get('vgpus', 0)
        else:
            vcpus = args.cpu or 2
            memory = args.memory or 2048
            vgpus = args.gpu or 0
        
        vm_id = self.system.hypervisor.create_vm(
            name=args.name,
            vcpus=vcpus,
            memory_mb=memory,
            vgpus=vgpus,
            kernel_path=args.kernel
        )
        
        print(f"‚úÖ VM created: {vm_id}")
        print(f"   vCPUs: {vcpus}")
        print(f"   Memory: {memory}MB")
        print(f"   vGPUs: {vgpus}")
        print()
    
    async def cmd_vm_start(self, args):
        """Start a VM: qctl vm start <vm_id>"""
        await self._ensure_system()
        
        print(f"‚ñ∂Ô∏è  Starting VM: {args.vm_id}")
        await self.system.hypervisor.start_vm(args.vm_id)
        print(f"‚úÖ VM started")
        print()
    
    async def cmd_vm_stop(self, args):
        """Stop a VM: qctl vm stop <vm_id>"""
        await self._ensure_system()
        
        print(f"‚è∏Ô∏è  Stopping VM: {args.vm_id}")
        await self.system.hypervisor.stop_vm(args.vm_id, force=args.force)
        print(f"‚úÖ VM stopped")
        print()
    
    async def cmd_vm_destroy(self, args):
        """Destroy a VM: qctl vm destroy <vm_id>"""
        await self._ensure_system()
        
        if not args.yes:
            response = input(f"‚ö†Ô∏è  Destroy VM {args.vm_id}? This cannot be undone. [y/N]: ")
            if response.lower() != 'y':
                print("Cancelled.")
                return
        
        print(f"üóëÔ∏è  Destroying VM: {args.vm_id}")
        self.system.hypervisor.destroy_vm(args.vm_id)
        print(f"‚úÖ VM destroyed")
        print()
    
    async def cmd_vm_console(self, args):
        """View VM console: qctl vm console <vm_id>"""
        await self._ensure_system()
        
        if args.vm_id not in self.system.hypervisor.vms:
            print(f"‚ùå VM not found: {args.vm_id}")
            return
        
        vm = self.system.hypervisor.vms[args.vm_id]
        
        print(f"\nüì∫ CONSOLE OUTPUT: {vm.name}")
        print("=" * 70)
        
        lines = vm.console_output[-args.lines:] if args.lines else vm.console_output
        for line in lines:
            print(line)
        
        print()
    
    # ============================================================
    # NODE COMMANDS
    # ============================================================
    
    async def cmd_node_list(self, args):
        """List cluster nodes: qctl node list"""
        await self._ensure_system()
        
        nodes = self.system.hypervisor.nodes
        
        if args.output:
            self._format_output({"nodes": list(nodes.values())}, args.output)
        else:
            print("\nüì° CLUSTER NODES")
            print("=" * 70)
            print(f"{'NODE ID':<20} {'vCPUS':<12} {'MEMORY':<15}")
            print("-" * 70)
            
            for node_id, node in nodes.items():
                print(f"{node_id:<20} {node['vcpus']:<12} {node['memory_mb']}MB{'':<8}")
            
            print(f"\nTotal: {len(nodes)} nodes")
            print()
    
    async def cmd_node_add(self, args):
        """Add a node: qctl node add <node_id> --cpu <n> --memory <mb>"""
        await self._ensure_system()
        
        print(f"üì° Adding node: {args.node_id}")
        
        self.system.hypervisor.register_node(
            args.node_id,
            vcpus=args.cpu,
            memory_mb=args.memory
        )
        
        print(f"‚úÖ Node added")
        print()
    
    # ============================================================
    # TASK COMMANDS
    # ============================================================
    
    async def cmd_task_submit(self, args):
        """Submit a task: qctl task submit <description>"""
        await self._ensure_system()
        
        print(f"üìã Submitting task...")
        print(f"   Description: {args.description}")
        
        # Brain analyzes and executes
        result = await self.system.request_compute(
            args.description,
            json.loads(args.data) if args.data else None
        )
        
        print(f"\n‚úÖ Task submitted")
        print(f"   Decision ID: {result['decision'].decision_id}")
        print(f"   VM ID: {result['vm_id']}")
        print(f"   Confidence: {result['decision'].confidence:.1%}")
        print(f"   Resources: {result['decision'].resources_needed}")
        print()
    
    # ============================================================
    # STATS COMMANDS
    # ============================================================
    
    async def cmd_stats(self, args):
        """Show system stats: qctl stats"""
        await self._ensure_system()
        
        brain_status = self.system.brain.get_brain_status()
        hv_stats = self.system.hypervisor.get_stats()
        
        print("\nüìä QUEZTL SYSTEM STATS")
        print("=" * 70)
        
        print("\nüß† BRAIN:")
        print(f"   Uptime: {brain_status['uptime_seconds']:.0f}s")
        print(f"   Tasks: {brain_status['metrics']['tasks_completed']}")
        print(f"   Decisions: {brain_status['metrics']['decisions_made']}")
        print(f"   Optimizations: {brain_status['metrics']['optimizations_applied']}")
        
        print("\nüéõÔ∏è  HYPERVISOR:")
        print(f"   VMs: {hv_stats['vms']['running']} running / {hv_stats['vms']['total']} total")
        cpu_pct = (hv_stats['resources']['vcpus_allocated'] / 
                   max(hv_stats['resources']['vcpus_total'], 1)) * 100
        mem_pct = (hv_stats['resources']['memory_allocated_mb'] / 
                   max(hv_stats['resources']['memory_total_mb'], 1)) * 100
        print(f"   CPU: {cpu_pct:.1f}% ({hv_stats['resources']['vcpus_allocated']}/{hv_stats['resources']['vcpus_total']} vCPUs)")
        print(f"   Memory: {mem_pct:.1f}% ({hv_stats['resources']['memory_allocated_mb']}/{hv_stats['resources']['memory_total_mb']}MB)")
        
        print("\nüì° CLUSTER:")
        print(f"   Nodes: {hv_stats['nodes']['total']}")
        print(f"   Mode: {'Distributed' if hv_stats['nodes']['distributed_mode'] else 'Local'}")
        print()
    
    # ============================================================
    # CONFIG COMMANDS
    # ============================================================
    
    def cmd_config_view(self, args):
        """View configuration: qctl config view"""
        print("\n‚öôÔ∏è  QUEZTL CLI CONFIGURATION")
        print("=" * 50)
        self._print_text(self.config)
        print()
    
    def cmd_config_set(self, args):
        """Set configuration: qctl config set <key> <value>"""
        self.config[args.key] = args.value
        self._save_config(self.config)
        print(f"‚úÖ Configuration updated: {args.key} = {args.value}")
        print()
    
    # ============================================================
    # VERSION & HELP
    # ============================================================
    
    def cmd_version(self, args):
        """Show version: qctl version"""
        print("\nü¶Ö Queztl CLI (qctl)")
        print("Version: 0.1.0-alpha")
        print("Architecture: Brain + Hypervisor + Linux")
        print()
    
    def cmd_help(self, args):
        """Show help"""
        print("""
ü¶Ö QUEZTL COMMAND LINE INTERFACE (qctl)

Unix-style CLI for Queztl's brain + hypervisor architecture.

USAGE:
    qctl <command> <subcommand> [options]

BRAIN COMMANDS:
    qctl brain status              Show brain status
    qctl brain knowledge           Show learned knowledge
    qctl brain optimize            Trigger optimization

VM COMMANDS:
    qctl vm list                   List all VMs
    qctl vm create <name>          Create a new VM
        --cpu <n>                  vCPUs (brain decides if omitted)
        --memory <mb>              Memory in MB
        --gpu <n>                  vGPUs
        --purpose <desc>           Purpose for brain analysis
    qctl vm start <vm_id>          Start a VM
    qctl vm stop <vm_id>           Stop a VM
        --force                    Force stop
    qctl vm destroy <vm_id>        Destroy a VM
        -y, --yes                  Skip confirmation
    qctl vm console <vm_id>        View VM console output
        --lines <n>                Number of lines (default: all)

NODE COMMANDS:
    qctl node list                 List cluster nodes
    qctl node add <id>             Add a node
        --cpu <n>                  vCPUs available
        --memory <mb>              Memory available

TASK COMMANDS:
    qctl task submit <desc>        Submit a task to brain
        --data <json>              Task data as JSON

STATS:
    qctl stats                     Show system statistics

CONFIG:
    qctl config view               View configuration
    qctl config set <key> <value>  Set configuration value

GLOBAL OPTIONS:
    -o, --output <format>          Output format: text, json, yaml
    -h, --help                     Show help
    -v, --version                  Show version

EXAMPLES:
    # Show brain status
    qctl brain status

    # Create VM (brain decides resources)
    qctl vm create mining-vm --purpose "MAG processing"

    # Create VM with specific resources
    qctl vm create ml-vm --cpu 16 --memory 32768 --gpu 4

    # List VMs in JSON format
    qctl vm list -o json

    # Submit a task
    qctl task submit "Process mining MAG survey" --data '{"survey_id":"MAG-001"}'

    # Add cluster node
    qctl node add node-2 --cpu 32 --memory 65536

For more information: https://docs.queztl.io
""")


def main():
    """Main CLI entry point"""
    
    cli = QueztlCLI()
    
    # Create argument parser
    parser = argparse.ArgumentParser(
        prog='qctl',
        description='Queztl Command Line Interface',
        add_help=False
    )
    
    # Global options
    parser.add_argument('-o', '--output', choices=['text', 'json', 'yaml'], help='Output format')
    parser.add_argument('-v', '--version', action='store_true', help='Show version')
    parser.add_argument('-h', '--help', action='store_true', help='Show help')
    
    # Subcommands
    subparsers = parser.add_subparsers(dest='command', help='Command')
    
    # BRAIN commands
    brain_parser = subparsers.add_parser('brain', help='Brain operations')
    brain_sub = brain_parser.add_subparsers(dest='subcommand')
    brain_sub.add_parser('status', help='Show brain status')
    brain_sub.add_parser('knowledge', help='Show learned knowledge')
    brain_sub.add_parser('optimize', help='Trigger optimization')
    
    # VM commands
    vm_parser = subparsers.add_parser('vm', help='Virtual machine operations')
    vm_sub = vm_parser.add_subparsers(dest='subcommand')
    vm_sub.add_parser('list', help='List VMs')
    
    vm_create = vm_sub.add_parser('create', help='Create VM')
    vm_create.add_argument('name', help='VM name')
    vm_create.add_argument('--cpu', type=int, help='vCPUs')
    vm_create.add_argument('--memory', type=int, help='Memory (MB)')
    vm_create.add_argument('--gpu', type=int, help='vGPUs')
    vm_create.add_argument('--purpose', help='Purpose for brain analysis')
    vm_create.add_argument('--kernel', help='Kernel path')
    
    vm_start = vm_sub.add_parser('start', help='Start VM')
    vm_start.add_argument('vm_id', help='VM ID')
    
    vm_stop = vm_sub.add_parser('stop', help='Stop VM')
    vm_stop.add_argument('vm_id', help='VM ID')
    vm_stop.add_argument('--force', action='store_true', help='Force stop')
    
    vm_destroy = vm_sub.add_parser('destroy', help='Destroy VM')
    vm_destroy.add_argument('vm_id', help='VM ID')
    vm_destroy.add_argument('-y', '--yes', action='store_true', help='Skip confirmation')
    
    vm_console = vm_sub.add_parser('console', help='View console')
    vm_console.add_argument('vm_id', help='VM ID')
    vm_console.add_argument('--lines', type=int, help='Number of lines')
    
    # NODE commands
    node_parser = subparsers.add_parser('node', help='Node management')
    node_sub = node_parser.add_subparsers(dest='subcommand')
    node_sub.add_parser('list', help='List nodes')
    
    node_add = node_sub.add_parser('add', help='Add node')
    node_add.add_argument('node_id', help='Node ID')
    node_add.add_argument('--cpu', type=int, required=True, help='vCPUs')
    node_add.add_argument('--memory', type=int, required=True, help='Memory (MB)')
    
    # TASK commands
    task_parser = subparsers.add_parser('task', help='Task operations')
    task_sub = task_parser.add_subparsers(dest='subcommand')
    
    task_submit = task_sub.add_parser('submit', help='Submit task')
    task_submit.add_argument('description', help='Task description')
    task_submit.add_argument('--data', help='Task data (JSON)')
    
    # STATS command
    subparsers.add_parser('stats', help='Show system stats')
    
    # CONFIG commands
    config_parser = subparsers.add_parser('config', help='Configuration')
    config_sub = config_parser.add_subparsers(dest='subcommand')
    config_sub.add_parser('view', help='View config')
    
    config_set = config_sub.add_parser('set', help='Set config value')
    config_set.add_argument('key', help='Config key')
    config_set.add_argument('value', help='Config value')
    
    # Parse arguments
    args = parser.parse_args()
    
    # Handle global options
    if args.version:
        cli.cmd_version(args)
        return
    
    if args.help or not args.command:
        cli.cmd_help(args)
        return
    
    # Route to command handler
    handler_name = f"cmd_{args.command}"
    if args.command in ['brain', 'vm', 'node', 'task', 'config'] and args.subcommand:
        handler_name = f"cmd_{args.command}_{args.subcommand}"
    
    handler = getattr(cli, handler_name, None)
    
    if handler:
        if asyncio.iscoroutinefunction(handler):
            asyncio.run(handler(args))
        else:
            handler(args)
    else:
        print(f"‚ùå Unknown command: {args.command}")
        cli.cmd_help(args)
        sys.exit(1)


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("\n\nüëã Interrupted")
        sys.exit(0)
    except Exception as e:
        print(f"\n‚ùå Error: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)
