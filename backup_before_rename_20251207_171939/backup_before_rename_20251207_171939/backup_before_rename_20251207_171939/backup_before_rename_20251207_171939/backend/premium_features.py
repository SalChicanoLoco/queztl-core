"""
Premium Features for 3D Model Generation
- STL export for 3D printing
- Multiple format support (OBJ, STL, PLY, GLTF)
- Model validation and repair
- Manifold mesh generation
- Scale normalization
"""
import numpy as np
import struct
from typing import Dict, Any, List, Tuple
import logging

logger = logging.getLogger(__name__)


class PremiumExporter:
    """Export 3D models in premium formats"""
    
    @staticmethod
    def to_stl(vertices: np.ndarray, faces: List[List[int]], name: str = "model") -> bytes:
        """
        Export to STL format for 3D printing
        
        STL (STereoLithography) is the standard format for 3D printing
        """
        # Ensure vertices are numpy array
        if not isinstance(vertices, np.ndarray):
            vertices = np.array(vertices)
        
        # Build STL binary format
        stl_data = bytearray()
        
        # Header (80 bytes)
        header = f"Generated by Queztl-Core - {name}".ljust(80, '\0')[:80]
        stl_data.extend(header.encode('ascii'))
        
        # Number of triangles (4 bytes, little-endian)
        num_triangles = len(faces)
        stl_data.extend(struct.pack('<I', num_triangles))
        
        # For each triangle
        for face in faces:
            if len(face) != 3:
                continue  # Skip non-triangular faces
            
            # Get vertices
            v0 = vertices[face[0]]
            v1 = vertices[face[1]]
            v2 = vertices[face[2]]
            
            # Calculate normal
            edge1 = v1 - v0
            edge2 = v2 - v0
            normal = np.cross(edge1, edge2)
            norm_len = np.linalg.norm(normal)
            if norm_len > 0:
                normal = normal / norm_len
            else:
                normal = np.array([0, 0, 1])
            
            # Write normal (3 floats)
            stl_data.extend(struct.pack('<fff', normal[0], normal[1], normal[2]))
            
            # Write vertices (3 vertices × 3 floats)
            stl_data.extend(struct.pack('<fff', v0[0], v0[1], v0[2]))
            stl_data.extend(struct.pack('<fff', v1[0], v1[1], v1[2]))
            stl_data.extend(struct.pack('<fff', v2[0], v2[1], v2[2]))
            
            # Attribute byte count (2 bytes, usually 0)
            stl_data.extend(struct.pack('<H', 0))
        
        return bytes(stl_data)
    
    @staticmethod
    def to_ply(vertices: np.ndarray, faces: List[List[int]], name: str = "model") -> str:
        """
        Export to PLY format (Polygon File Format)
        
        PLY is a flexible format supporting colors, normals, and other properties
        """
        # Ensure vertices are numpy array
        if not isinstance(vertices, np.ndarray):
            vertices = np.array(vertices)
        
        ply_data = []
        
        # Header
        ply_data.append("ply")
        ply_data.append("format ascii 1.0")
        ply_data.append(f"comment Generated by Queztl-Core - {name}")
        ply_data.append(f"element vertex {len(vertices)}")
        ply_data.append("property float x")
        ply_data.append("property float y")
        ply_data.append("property float z")
        ply_data.append(f"element face {len(faces)}")
        ply_data.append("property list uchar int vertex_indices")
        ply_data.append("end_header")
        
        # Vertices
        for v in vertices:
            ply_data.append(f"{v[0]} {v[1]} {v[2]}")
        
        # Faces
        for face in faces:
            indices = " ".join(str(idx) for idx in face)
            ply_data.append(f"{len(face)} {indices}")
        
        return "\n".join(ply_data)
    
    @staticmethod
    def to_gltf(vertices: np.ndarray, faces: List[List[int]], name: str = "model") -> Dict:
        """
        Export to GLTF format (GL Transmission Format)
        
        GLTF is the modern standard for 3D on the web
        """
        import json
        import base64
        
        # Ensure vertices are numpy array
        if not isinstance(vertices, np.ndarray):
            vertices = np.array(vertices, dtype=np.float32)
        
        # Flatten vertices
        vertices_flat = vertices.flatten().tobytes()
        vertices_b64 = base64.b64encode(vertices_flat).decode('ascii')
        
        # Convert faces to flat indices
        indices = []
        for face in faces:
            indices.extend(face)
        indices_array = np.array(indices, dtype=np.uint16)
        indices_flat = indices_array.tobytes()
        indices_b64 = base64.b64encode(indices_flat).decode('ascii')
        
        # Calculate bounds
        min_vals = vertices.min(axis=0).tolist()
        max_vals = vertices.max(axis=0).tolist()
        
        # GLTF structure
        gltf = {
            "asset": {
                "version": "2.0",
                "generator": "Queztl-Core Premium Exporter"
            },
            "scene": 0,
            "scenes": [{"nodes": [0]}],
            "nodes": [{"mesh": 0}],
            "meshes": [{
                "primitives": [{
                    "attributes": {"POSITION": 0},
                    "indices": 1,
                    "mode": 4  # TRIANGLES
                }]
            }],
            "buffers": [{
                "byteLength": len(vertices_flat) + len(indices_flat),
                "uri": f"data:application/octet-stream;base64,{vertices_b64}{indices_b64}"
            }],
            "bufferViews": [
                {
                    "buffer": 0,
                    "byteOffset": 0,
                    "byteLength": len(vertices_flat),
                    "target": 34962  # ARRAY_BUFFER
                },
                {
                    "buffer": 0,
                    "byteOffset": len(vertices_flat),
                    "byteLength": len(indices_flat),
                    "target": 34963  # ELEMENT_ARRAY_BUFFER
                }
            ],
            "accessors": [
                {
                    "bufferView": 0,
                    "byteOffset": 0,
                    "componentType": 5126,  # FLOAT
                    "count": len(vertices),
                    "type": "VEC3",
                    "min": min_vals,
                    "max": max_vals
                },
                {
                    "bufferView": 1,
                    "byteOffset": 0,
                    "componentType": 5123,  # UNSIGNED_SHORT
                    "count": len(indices),
                    "type": "SCALAR"
                }
            ]
        }
        
        return gltf


class MeshValidator:
    """Validate and repair 3D meshes"""
    
    @staticmethod
    def is_manifold(vertices: np.ndarray, faces: List[List[int]]) -> bool:
        """Check if mesh is manifold (watertight, suitable for 3D printing)"""
        # Build edge map
        edges = {}
        
        for face in faces:
            if len(face) != 3:
                continue
            
            # Each triangle has 3 edges
            for i in range(3):
                v1, v2 = face[i], face[(i + 1) % 3]
                edge = tuple(sorted([v1, v2]))
                edges[edge] = edges.get(edge, 0) + 1
        
        # Manifold mesh: each edge shared by exactly 2 faces
        for count in edges.values():
            if count != 2:
                return False
        
        return True
    
    @staticmethod
    def remove_duplicate_vertices(vertices: np.ndarray, faces: List[List[int]], 
                                  tolerance: float = 1e-6) -> Tuple[np.ndarray, List[List[int]]]:
        """Remove duplicate vertices and update faces"""
        unique_vertices = []
        vertex_map = {}
        
        for i, v in enumerate(vertices):
            # Check if vertex already exists
            found = False
            for j, uv in enumerate(unique_vertices):
                if np.linalg.norm(v - uv) < tolerance:
                    vertex_map[i] = j
                    found = True
                    break
            
            if not found:
                vertex_map[i] = len(unique_vertices)
                unique_vertices.append(v)
        
        # Update faces
        new_faces = []
        for face in faces:
            new_face = [vertex_map[idx] for idx in face]
            # Skip degenerate faces
            if len(set(new_face)) == len(new_face):
                new_faces.append(new_face)
        
        return np.array(unique_vertices), new_faces
    
    @staticmethod
    def normalize_scale(vertices: np.ndarray, target_size: float = 100.0) -> np.ndarray:
        """
        Normalize model to target size (in mm for 3D printing)
        
        Args:
            vertices: Model vertices
            target_size: Target size in millimeters (default: 100mm = 10cm)
        """
        # Find current bounds
        min_vals = vertices.min(axis=0)
        max_vals = vertices.max(axis=0)
        current_size = (max_vals - min_vals).max()
        
        if current_size == 0:
            return vertices
        
        # Scale to target size
        scale_factor = target_size / current_size
        center = (min_vals + max_vals) / 2
        
        # Center and scale
        vertices_centered = vertices - center
        vertices_scaled = vertices_centered * scale_factor
        
        return vertices_scaled
    
    @staticmethod
    def calculate_volume(vertices: np.ndarray, faces: List[List[int]]) -> float:
        """Calculate mesh volume (useful for material estimation in 3D printing)"""
        volume = 0.0
        
        for face in faces:
            if len(face) != 3:
                continue
            
            v0 = vertices[face[0]]
            v1 = vertices[face[1]]
            v2 = vertices[face[2]]
            
            # Signed volume of tetrahedron formed by face and origin
            volume += np.dot(v0, np.cross(v1, v2)) / 6.0
        
        return abs(volume)
    
    @staticmethod
    def calculate_surface_area(vertices: np.ndarray, faces: List[List[int]]) -> float:
        """Calculate mesh surface area"""
        area = 0.0
        
        for face in faces:
            if len(face) != 3:
                continue
            
            v0 = vertices[face[0]]
            v1 = vertices[face[1]]
            v2 = vertices[face[2]]
            
            # Area of triangle using cross product
            edge1 = v1 - v0
            edge2 = v2 - v0
            cross = np.cross(edge1, edge2)
            area += np.linalg.norm(cross) / 2.0
        
        return area


def analyze_printability(vertices: np.ndarray, faces: List[List[int]]) -> Dict[str, Any]:
    """Analyze if model is suitable for 3D printing"""
    validator = MeshValidator()
    
    is_manifold = validator.is_manifold(vertices, faces)
    volume = validator.calculate_volume(vertices, faces)
    surface_area = validator.calculate_surface_area(vertices, faces)
    
    # Check for minimum size
    min_vals = vertices.min(axis=0)
    max_vals = vertices.max(axis=0)
    dimensions = max_vals - min_vals
    min_dimension = dimensions.min()
    
    issues = []
    if not is_manifold:
        issues.append("Mesh is not manifold (not watertight)")
    if min_dimension < 1.0:
        issues.append(f"Model too small (min dimension: {min_dimension:.2f}mm)")
    if volume < 0.1:
        issues.append("Volume too small for reliable printing")
    
    return {
        "printable": len(issues) == 0,
        "is_manifold": is_manifold,
        "volume_mm3": volume,
        "surface_area_mm2": surface_area,
        "dimensions_mm": {
            "x": float(dimensions[0]),
            "y": float(dimensions[1]),
            "z": float(dimensions[2])
        },
        "issues": issues,
        "recommendations": [
            "Scale model to at least 10mm in smallest dimension" if min_dimension < 10 else "",
            "Use 0.2mm layer height for best results",
            "Consider adding supports for overhangs > 45°"
        ]
    }
