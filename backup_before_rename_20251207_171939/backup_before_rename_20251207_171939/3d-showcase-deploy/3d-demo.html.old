<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ü¶Ö Queztl-Core 3DMark - GPU Benchmark Suite</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0f0c29, #302b63, #24243e);
            color: #fff;
            overflow-x: hidden;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            padding: 40px 0;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            margin-bottom: 30px;
        }

        .back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            padding: 10px 20px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            color: white;
            text-decoration: none;
            transition: all 0.3s;
            z-index: 1000;
        }

        .back-link:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .header h1 {
            font-size: 3em;
            margin-bottom: 10px;
            background: linear-gradient(45deg, #00f260, #0575e6);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .header p {
            font-size: 1.2em;
            color: #aaa;
        }

        .benchmark-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .test-card {
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid #333;
            border-radius: 10px;
            padding: 20px;
            transition: all 0.3s ease;
        }

        .test-card:hover {
            border-color: #0575e6;
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(5, 117, 230, 0.3);
        }

        .test-card h3 {
            font-size: 1.5em;
            margin-bottom: 10px;
            color: #0575e6;
        }

        .test-card p {
            color: #aaa;
            margin-bottom: 15px;
            font-size: 0.9em;
        }

        .test-card button {
            width: 100%;
            padding: 12px;
            background: linear-gradient(45deg, #00f260, #0575e6);
            border: none;
            border-radius: 5px;
            color: white;
            font-size: 1em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .test-card button:hover {
            transform: scale(1.05);
            box-shadow: 0 5px 20px rgba(5, 117, 230, 0.5);
        }

        .test-card button:disabled {
            background: #555;
            cursor: not-allowed;
            transform: none;
        }

        .test-status {
            margin-top: 15px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 5px;
            font-size: 0.9em;
            min-height: 60px;
        }

        .status-idle {
            color: #aaa;
        }

        .status-running {
            color: #00f260;
            animation: pulse 1.5s infinite;
        }

        .status-complete {
            color: #00f260;
        }

        .status-error {
            color: #ff4444;
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.5;
            }
        }

        .results-panel {
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid #333;
            border-radius: 10px;
            padding: 30px;
            margin-top: 30px;
        }

        .results-panel h2 {
            font-size: 2em;
            margin-bottom: 20px;
            text-align: center;
            color: #0575e6;
        }

        .score-display {
            text-align: center;
            padding: 40px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            margin-bottom: 30px;
        }

        .score-number {
            font-size: 5em;
            font-weight: bold;
            background: linear-gradient(45deg, #00f260, #0575e6);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .score-label {
            font-size: 1.5em;
            color: #aaa;
            margin-top: 10px;
        }

        .score-grade {
            font-size: 2em;
            margin-top: 10px;
            font-weight: bold;
        }

        .test-results {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .result-item {
            background: rgba(255, 255, 255, 0.05);
            padding: 20px;
            border-radius: 5px;
            border-left: 4px solid #0575e6;
        }

        .result-item h4 {
            margin-bottom: 10px;
            color: #00f260;
        }

        .result-metric {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            padding: 5px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .result-metric:last-child {
            border-bottom: none;
        }

        .metric-label {
            color: #aaa;
        }

        .metric-value {
            color: #fff;
            font-weight: bold;
        }

        .run-all-button {
            text-align: center;
            margin: 30px 0;
        }

        .run-all-button button {
            padding: 20px 50px;
            font-size: 1.5em;
            background: linear-gradient(45deg, #00f260, #0575e6);
            border: none;
            border-radius: 10px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .run-all-button button:hover {
            transform: scale(1.1);
            box-shadow: 0 10px 40px rgba(5, 117, 230, 0.5);
        }

        .progress-bar {
            width: 100%;
            height: 30px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            overflow: hidden;
            margin-top: 20px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(45deg, #00f260, #0575e6);
            transition: width 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
        }

        .canvas-container {
            display: none;
            width: 100%;
            height: 400px;
            background: #000;
            border-radius: 10px;
            margin-top: 20px;
            position: relative;
        }

        .canvas-container canvas {
            width: 100%;
            height: 100%;
            border-radius: 10px;
        }

        .comparison-section {
            margin-top: 30px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
        }

        .comparison-section h3 {
            margin-bottom: 15px;
            color: #00f260;
        }

        .comparison-bar {
            margin: 10px 0;
            height: 30px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 5px;
            position: relative;
            overflow: hidden;
        }

        .comparison-fill {
            height: 100%;
            background: linear-gradient(90deg, #00f260, #0575e6);
            display: flex;
            align-items: center;
            padding-left: 10px;
            font-size: 0.9em;
            font-weight: bold;
        }

        .footer {
            text-align: center;
            margin-top: 50px;
            padding: 20px;
            color: #666;
        }
    </style>
</head>

<body>
    <a href="demos.html" class="back-link">‚Üê Back to Demos</a>
    <div class="container">
        <div class="header">
            <h1>ü¶Ö Queztl-Core 3DMark</h1>
            <p>Professional GPU Benchmark Suite - Powered by WebGPU Driver</p>

            <!-- API Configuration Panel -->
            <div
                style="margin-top: 20px; padding: 15px; background: rgba(0,0,0,0.3); border-radius: 8px; max-width: 700px; margin-left: auto; margin-right: auto;">
                <h4 style="margin-bottom: 10px; color: #00f260;">üåê API Configuration</h4>
                <p style="font-size: 12px; color: #aaa; margin-bottom: 10px;">
                    Enter your Queztl-Core API endpoint to test performance
                </p>

                <!-- Quick Select Presets -->
                <div style="display: flex; gap: 8px; margin-bottom: 10px; flex-wrap: wrap;">
                    <button onclick="setApiUrl('http://localhost:8000')"
                        style="padding: 6px 12px; border-radius: 5px; border: 1px solid #555; background: rgba(255,255,255,0.05); color: #fff; cursor: pointer; font-size: 12px;">
                        üè† Localhost
                    </button>
                    <button onclick="setApiUrl('https://queztl-core-api.onrender.com')"
                        style="padding: 6px 12px; border-radius: 5px; border: 1px solid #555; background: rgba(255,255,255,0.05); color: #fff; cursor: pointer; font-size: 12px;">
                        ‚òÅÔ∏è Production (Render)
                    </button>
                    <button onclick="setApiUrl('https://hive-backend.onrender.com')"
                        style="padding: 6px 12px; border-radius: 5px; border: 1px solid #555; background: rgba(255,255,255,0.05); color: #fff; cursor: pointer; font-size: 12px;">
                        üêù Hive Backend
                    </button>
                </div>

                <div style="display: flex; gap: 10px; align-items: center; margin-bottom: 10px;">
                    <input type="text" id="apiUrl" placeholder="https://your-api.example.com"
                        style="flex: 1; padding: 10px 12px; border-radius: 5px; border: 1px solid #555; background: rgba(255,255,255,0.1); color: #fff; font-size: 14px;" />
                    <button onclick="testApiConnection()"
                        style="padding: 10px 20px; border-radius: 5px; border: none; background: linear-gradient(45deg, #00f260, #0575e6); color: #fff; cursor: pointer; font-weight: bold; font-size: 14px;">
                        üîå Test Connection
                    </button>
                </div>
                <div id="apiStatus"
                    style="font-size: 13px; color: #aaa; padding: 8px; background: rgba(0,0,0,0.2); border-radius: 5px;">
                    üí° Select a preset or enter custom URL, then test connection
                </div>
            </div>
        </div>

        <div class="run-all-button">
            <button id="runAllBtn" onclick="runAllTests()">
                üöÄ RUN ALL BENCHMARKS
            </button>
        </div>

        <div class="progress-bar" id="progressBar" style="display: none;">
            <div class="progress-fill" id="progressFill" style="width: 0%;">0%</div>
        </div>

        <div class="benchmark-grid">
            <!-- Test 1: Geometry Processing -->
            <div class="test-card">
                <h3>üìê Geometry Processing</h3>
                <p>Tests buffer creation, mesh upload, and triangle processing with increasing complexity.</p>
                <button onclick="runTest('geometry')">Run Test</button>
                <div class="test-status status-idle" id="status-geometry">
                    Ready to run
                </div>
            </div>

            <!-- Test 2: Throughput Stress Test -->
            <div class="test-card">
                <h3>‚ö° Throughput Stress</h3>
                <p>Measures maximum operations per second under sustained load.</p>
                <button onclick="runTest('throughput')">Run Test</button>
                <div class="test-status status-idle" id="status-throughput">
                    Ready to run
                </div>
            </div>

            <!-- Test 3: Latency Test -->
            <div class="test-card">
                <h3>‚è±Ô∏è Latency Test</h3>
                <p>Measures response time for individual operations (P50, P95, P99).</p>
                <button onclick="runTest('latency')">Run Test</button>
                <div class="test-status status-idle" id="status-latency">
                    Ready to run
                </div>
            </div>

            <!-- Test 4: Concurrency Test -->
            <div class="test-card">
                <h3>üîÄ Concurrency Test</h3>
                <p>Tests parallel request handling with multiple concurrent workers.</p>
                <button onclick="runTest('concurrency')">Run Test</button>
                <div class="test-status status-idle" id="status-concurrency">
                    Ready to run
                </div>
            </div>

            <!-- Test 5: Memory Stress -->
            <div class="test-card">
                <h3>üíæ Memory Stress</h3>
                <p>Tests memory allocation, buffer management, and leak detection.</p>
                <button onclick="runTest('memory')">Run Test</button>
                <div class="test-status status-idle" id="status-memory">
                    Ready to run
                </div>
            </div>

            <!-- Test 6: Complex Scene -->
            <div class="test-card">
                <h3>üé® Complex Scene</h3>
                <p>Renders a complex scene with multiple objects and high polygon count.</p>
                <button onclick="runTest('scene')">Run Test</button>
                <div class="test-status status-idle" id="status-scene">
                    Ready to run
                </div>
            </div>
        </div>

        <div class="results-panel" id="resultsPanel" style="display: none;">
            <h2>üìä Benchmark Results</h2>

            <div class="score-display">
                <div class="score-number" id="totalScore">0</div>
                <div class="score-label">Overall Score</div>
                <div class="score-grade" id="scoreGrade">-</div>
            </div>

            <div class="test-results" id="testResults"></div>

            <div class="comparison-section">
                <h3>üåç Real-World Comparison</h3>
                <div id="comparisonData"></div>
            </div>
        </div>

        <div class="footer">
            <p>ü¶Ö Queztl-Core v1.1.0 - Professional GPU Benchmarking</p>
            <p>Powered by Software GPU with 8,192 parallel threads</p>
        </div>
    </div>

    <script>
        // API Configuration - Defaults to Hive Backend (cloud)
        let API_URL = localStorage.getItem('queztl_api_url') || 'https://hive-backend.onrender.com';

        const testResults = {};
        let isRunning = false;

        // Initialize API URL input on page load
        window.addEventListener('DOMContentLoaded', () => {
            const apiUrlInput = document.getElementById('apiUrl');
            if (apiUrlInput) {
                apiUrlInput.value = API_URL;
            }
            // Auto-check API connection on load
            checkApiHealth();
        });

        // Quick set API URL from presets
        function setApiUrl(url) {
            document.getElementById('apiUrl').value = url;
            API_URL = url;
            localStorage.setItem('queztl_api_url', url);
            showStatus('üîÑ URL set to: ' + url, 'info');
            // Auto-test the connection
            setTimeout(() => testApiConnection(), 100);
        }

        // Function to update API URL
        function updateApiUrl(url) {
            API_URL = url;
            localStorage.setItem('queztl_api_url', url);
            const apiUrlInput = document.getElementById('apiUrl');
            if (apiUrlInput) {
                apiUrlInput.value = url;
            }
            showStatus('‚úÖ API URL updated: ' + url, 'success');
        }

        // Function to test API connection
        async function testApiConnection() {
            const apiUrlInput = document.getElementById('apiUrl');
            const testUrl = apiUrlInput ? apiUrlInput.value : API_URL;
            try {
                const response = await fetch(`${testUrl}/api/health`, { signal: AbortSignal.timeout(5000) });
                if (response.ok) {
                    updateApiUrl(testUrl);
                    showStatus('‚úÖ Connected to API successfully!', 'success');
                    return true;
                } else {
                    showStatus('‚ùå API returned error: ' + response.status, 'error');
                    return false;
                }
            } catch (error) {
                showStatus('‚ùå Cannot reach API: ' + error.message, 'error');
                return false;
            }
        }

        // Check API health quietly
        async function checkApiHealth() {
            try {
                const response = await fetch(`${API_URL}/api/health`, { signal: AbortSignal.timeout(5000) });
                if (response.ok) {
                    showStatus('‚úÖ API Connected', 'success');
                } else {
                    showStatus('‚ö†Ô∏è API not responding', 'warning');
                }
            } catch (error) {
                showStatus('‚ö†Ô∏è API offline - Please check connection', 'warning');
            }
        }

        // Show status message
        function showStatus(message, type) {
            const statusEl = document.getElementById('apiStatus');
            if (statusEl) {
                statusEl.textContent = message;
                statusEl.style.color = type === 'success' ? '#00f260' :
                    type === 'error' ? '#ff4444' :
                        type === 'warning' ? '#ffa500' : '#aaa';
            }
        }

        async function runTest(testName) {
            if (isRunning) {
                alert('A test is already running. Please wait.');
                return;
            }

            isRunning = true;
            const statusEl = document.getElementById(`status-${testName}`);
            statusEl.className = 'test-status status-running';
            statusEl.textContent = 'Running...';

            try {
                let result;
                switch (testName) {
                    case 'geometry':
                        result = await runGeometryTest();
                        break;
                    case 'throughput':
                        result = await runThroughputTest();
                        break;
                    case 'latency':
                        result = await runLatencyTest();
                        break;
                    case 'concurrency':
                        result = await runConcurrencyTest();
                        break;
                    case 'memory':
                        result = await runMemoryTest();
                        break;
                    case 'scene':
                        result = await runSceneTest();
                        break;
                }

                testResults[testName] = result;
                statusEl.className = 'test-status status-complete';
                statusEl.innerHTML = `‚úÖ Complete<br>Score: ${result.score}/100<br>Time: ${result.time}ms`;

                updateResults();
            } catch (error) {
                statusEl.className = 'test-status status-error';
                statusEl.innerHTML = `‚ùå Error<br>${error.message}`;
            } finally {
                isRunning = false;
            }
        }

        async function runAllTests() {
            const tests = ['geometry', 'throughput', 'latency', 'concurrency', 'memory', 'scene'];
            const progressBar = document.getElementById('progressBar');
            const progressFill = document.getElementById('progressFill');
            const runAllBtn = document.getElementById('runAllBtn');

            runAllBtn.disabled = true;
            progressBar.style.display = 'block';

            for (let i = 0; i < tests.length; i++) {
                await runTest(tests[i]);
                const progress = ((i + 1) / tests.length) * 100;
                progressFill.style.width = `${progress}%`;
                progressFill.textContent = `${Math.round(progress)}%`;

                // Small delay between tests
                await new Promise(resolve => setTimeout(resolve, 500));
            }

            runAllBtn.disabled = false;
            progressFill.textContent = '‚úÖ Complete!';
        }

        async function runGeometryTest() {
            const startTime = performance.now();
            const meshes = [
                { name: 'Cube', vertices: 8, triangles: 12 },
                { name: 'Sphere', vertices: 482, triangles: 960 },
                { name: 'Complex', vertices: 2000, triangles: 4000 }
            ];

            let totalTime = 0;
            const results = [];

            for (const mesh of meshes) {
                // Generate dummy vertex data
                const vertices = Array(mesh.vertices * 3).fill(0).map(() => Math.random() * 10);
                const indices = Array(mesh.triangles * 3).fill(0).map((_, i) => i % mesh.vertices);

                const meshStart = performance.now();
                const response = await fetch(`${API_URL}/api/gpu/render`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ vertices, indices, width: 512, height: 512 })
                });
                const data = await response.json();
                const meshTime = performance.now() - meshStart;

                totalTime += meshTime;
                results.push({ mesh: mesh.name, time: meshTime.toFixed(2), ...data });
            }

            const endTime = performance.now();
            const score = Math.max(0, 100 - (totalTime / 10)); // Scale score

            return {
                score: Math.round(score),
                time: (endTime - startTime).toFixed(2),
                details: results
            };
        }

        async function runThroughputTest() {
            const startTime = performance.now();

            const response = await fetch(`${API_URL}/api/power/benchmark`, {
                method: 'POST'
            });
            const data = await response.json();

            const endTime = performance.now();
            const throughput = data.tests.throughput.operations_per_second;

            // Score based on throughput (5.82M = 100 points)
            const score = Math.min(100, (throughput / 58200) * 100);

            return {
                score: Math.round(score),
                time: (endTime - startTime).toFixed(2),
                details: data.tests.throughput
            };
        }

        async function runLatencyTest() {
            const startTime = performance.now();
            const iterations = 100;
            const latencies = [];

            for (let i = 0; i < iterations; i++) {
                const iterStart = performance.now();
                await fetch(`${API_URL}/api/gpu/info`);
                latencies.push(performance.now() - iterStart);
            }

            latencies.sort((a, b) => a - b);
            const p50 = latencies[Math.floor(iterations * 0.5)];
            const p95 = latencies[Math.floor(iterations * 0.95)];
            const p99 = latencies[Math.floor(iterations * 0.99)];
            const avg = latencies.reduce((a, b) => a + b) / iterations;

            const endTime = performance.now();

            // Score based on P95 latency (lower is better)
            const score = Math.max(0, 100 - (p95 / 2));

            return {
                score: Math.round(score),
                time: (endTime - startTime).toFixed(2),
                details: {
                    iterations,
                    avg_ms: avg.toFixed(2),
                    p50_ms: p50.toFixed(2),
                    p95_ms: p95.toFixed(2),
                    p99_ms: p99.toFixed(2)
                }
            };
        }

        async function runConcurrencyTest() {
            const startTime = performance.now();
            const workers = 10;
            const opsPerWorker = 50;

            const promises = [];
            for (let i = 0; i < workers; i++) {
                promises.push((async () => {
                    for (let j = 0; j < opsPerWorker; j++) {
                        await fetch(`${API_URL}/api/health`);
                    }
                })());
            }

            await Promise.all(promises);
            const endTime = performance.now();
            const totalTime = (endTime - startTime) / 1000;
            const opsPerSec = (workers * opsPerWorker) / totalTime;

            // Score based on ops/sec (1000 = 100 points)
            const score = Math.min(100, (opsPerSec / 10) * 100);

            return {
                score: Math.round(score),
                time: totalTime.toFixed(2),
                details: {
                    workers,
                    ops_per_worker: opsPerWorker,
                    total_ops: workers * opsPerWorker,
                    ops_per_second: opsPerSec.toFixed(2)
                }
            };
        }

        async function runMemoryTest() {
            const startTime = performance.now();

            // Test memory allocation
            const response = await fetch(`${API_URL}/api/security/memory`);
            const data = await response.json();

            // Create and cleanup buffers
            const bufferTests = [];
            for (let i = 0; i < 10; i++) {
                const res = await fetch(`${API_URL}/api/gpu/buffer/create`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ size: 10240, buffer_type: 'vertex' })
                });
                bufferTests.push(await res.json());
            }

            const endTime = performance.now();

            // Score based on successful allocations and no leaks
            const score = data.leak_detection.has_leaks ? 50 : 100;

            return {
                score,
                time: (endTime - startTime).toFixed(2),
                details: {
                    buffers_created: bufferTests.length,
                    leak_detection: data.leak_detection,
                    active_allocations: data.active_allocations_count
                }
            };
        }

        async function runSceneTest() {
            const startTime = performance.now();

            // Complex scene with multiple objects
            const objects = [
                { vertices: 100, triangles: 200 },
                { vertices: 500, triangles: 1000 },
                { vertices: 1000, triangles: 2000 },
                { vertices: 2000, triangles: 4000 },
                { vertices: 5000, triangles: 10000 }
            ];

            const results = [];
            for (const obj of objects) {
                const vertices = Array(obj.vertices * 3).fill(0).map(() => Math.random() * 10);
                const indices = Array(obj.triangles * 3).fill(0).map((_, i) => i % obj.vertices);

                const response = await fetch(`${API_URL}/api/gpu/render`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ vertices, indices, width: 1024, height: 1024 })
                });
                results.push(await response.json());
            }

            const endTime = performance.now();
            const totalTime = endTime - startTime;

            // Score based on time (under 2s = 100 points)
            const score = Math.max(0, 100 - (totalTime / 20));

            return {
                score: Math.round(score),
                time: totalTime.toFixed(2),
                details: {
                    total_objects: objects.length,
                    total_vertices: objects.reduce((sum, obj) => sum + obj.vertices, 0),
                    total_triangles: objects.reduce((sum, obj) => sum + obj.triangles, 0),
                    results
                }
            };
        }

        function updateResults() {
            const resultsPanel = document.getElementById('resultsPanel');
            const testResultsEl = document.getElementById('testResults');
            const totalScoreEl = document.getElementById('totalScore');
            const scoreGradeEl = document.getElementById('scoreGrade');
            const comparisonDataEl = document.getElementById('comparisonData');

            resultsPanel.style.display = 'block';

            // Calculate total score
            const scores = Object.values(testResults).map(r => r.score);
            const totalScore = scores.length > 0 ? Math.round(scores.reduce((a, b) => a + b) / scores.length) : 0;

            totalScoreEl.textContent = totalScore;

            // Determine grade
            let grade, gradeColor;
            if (totalScore >= 90) {
                grade = 'S - EXCEPTIONAL üåü';
                gradeColor = '#FFD700';
            } else if (totalScore >= 80) {
                grade = 'A - EXCELLENT ‚≠ê';
                gradeColor = '#00f260';
            } else if (totalScore >= 70) {
                grade = 'B - VERY GOOD ‚úÖ';
                gradeColor = '#0575e6';
            } else if (totalScore >= 60) {
                grade = 'C - GOOD üëç';
                gradeColor = '#FFA500';
            } else {
                grade = 'D - FAIR üìä';
                gradeColor = '#FF4444';
            }
            scoreGradeEl.textContent = grade;
            scoreGradeEl.style.color = gradeColor;

            // Display individual test results
            testResultsEl.innerHTML = '';
            for (const [testName, result] of Object.entries(testResults)) {
                const resultItem = document.createElement('div');
                resultItem.className = 'result-item';
                resultItem.innerHTML = `
                    <h4>${formatTestName(testName)}</h4>
                    <div class="result-metric">
                        <span class="metric-label">Score:</span>
                        <span class="metric-value">${result.score}/100</span>
                    </div>
                    <div class="result-metric">
                        <span class="metric-label">Time:</span>
                        <span class="metric-value">${result.time}ms</span>
                    </div>
                    ${formatDetails(result.details)}
                `;
                testResultsEl.appendChild(resultItem);
            }

            // Comparison data
            comparisonDataEl.innerHTML = `
                <div class="comparison-bar">
                    <div class="comparison-fill" style="width: ${Math.min(100, totalScore)}%;">
                        Queztl-Core: ${totalScore}/100
                    </div>
                </div>
                <p style="margin-top: 15px; color: #aaa;">
                    ${totalScore >= 80 ? '‚úÖ Production-ready performance!' : ''}
                    ${totalScore >= 60 && totalScore < 80 ? '‚ú® Good performance for most workloads' : ''}
                    ${totalScore < 60 ? 'üîß Room for optimization' : ''}
                </p>
            `;
        }

        function formatTestName(name) {
            const names = {
                'geometry': 'üìê Geometry Processing',
                'throughput': '‚ö° Throughput Stress',
                'latency': '‚è±Ô∏è Latency Test',
                'concurrency': 'üîÄ Concurrency Test',
                'memory': 'üíæ Memory Stress',
                'scene': 'üé® Complex Scene'
            };
            return names[name] || name;
        }

        function formatDetails(details) {
            if (!details) return '';

            let html = '';
            for (const [key, value] of Object.entries(details)) {
                if (typeof value === 'object' && !Array.isArray(value)) continue;
                if (Array.isArray(value)) continue;

                html += `
                    <div class="result-metric">
                        <span class="metric-label">${key.replace(/_/g, ' ')}:</span>
                        <span class="metric-value">${value}</span>
                    </div>
                `;
            }
            return html;
        }

        // Check auth on load
        window.addEventListener('DOMContentLoaded', () => {
            const token = localStorage.getItem('queztl_auth');
            if (!token) {
                window.location.href = 'login.html';
            }
        });

        // Check API on load
        window.addEventListener('load', async () => {
            try {
                const response = await fetch(`${API_URL}/api/health`);
                if (!response.ok) throw new Error('API not responding');
                console.log('‚úÖ Queztl-Core API connected');
            } catch (error) {
                console.warn('‚ö†Ô∏è API not available at ' + API_URL);
            }
        });
    </script>
</body>

</html>